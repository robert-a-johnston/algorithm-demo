{"version":3,"sources":["components/header/Header.js","algorithms/sorts/MergeSort.js","algorithms/sorts/QuickSort.js","algorithms/sorts/BubbleSort.js","components/sort-display/create-array-functions/CreateArray.js","components/sort-display/create-array-functions/ResetArrayColor.js","components/sort-display/create-array-functions/ShuffleArray.js","algorithms/algo-images/quickSortAlgo.JPG","algorithms/info/quick-sort/QuickSortInfo.js","algorithms/algo-images/mergeSortAlgo.JPG","algorithms/info/merge-sort/MergeSort.js","algorithms/algo-images/bubbleSortAlgo.JPG","algorithms/info/bubble-sort/BubbleSortInfo.js","components/sort-display/SortDisplay.js","components/path-finder/node/Node.js","algorithms/searches/Dijkstra.js","algorithms/searches/AStar.js","algorithms/info/dijkstra/DijkstraInfo.js","algorithms/info/a-star/AstarInfo.js","algorithms/info/breath-first-search/BreathFirstSearchInfo.js","algorithms/info/depth-first-search/DepthFirstSearchInfo.js","components/path-finder/graph/Graph.js","algorithms/searches/BreathFirstSearch.js","algorithms/searches/DepthFirstSearch.js","components/home/algoBackground.jpg","components/home/Home.js","App.js","index.js"],"names":["Header","className","Navbar","Brand","Nav","to","href","target","rel","getMergeSortAnimations","arr","copyArray","len","length","animations","mergeSortHelper","Array","tempArray","left","right","mid","Math","floor","i","j","k","push","merge","quickSortAnimations","quickSort","start","end","part","pivot","swap","partition","index1","index2","temp","bubbleSortAnimations","isSwapped","bubbleSort","createArray","containerRef","intArr","arrayBars","current","children","style","backgroundColor","resetArrayColour","tempArr","arrayValue","MAX_VALUE","array","random","shuffleArray","QuickSortInfo","src","quickSortAlgo","alt","MergeSortInfo","mergeSortAlgo","BubbleSortInfo","bubbleSortAlgo","DELAY","PRIMARY_COLOR","SortDisplay","useState","setIntArr","info","setInfo","useRef","disabled","setDisabled","disableCreate","setDisableCreate","animateArrayUpdate","forEach","index","comparison","swapped","setTimeout","prevArr","newValue","newArr","animateArrayAccess","console","log","arrayBarStyle","animateSortedArray","useEffect","id","onClick","ref","map","barHeight","height","width","color","Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","AStar","sortByDistance","distanceToFinishNode","DijkstraInfo","AstarInfo","type","DepthFirstSearchInfo","Graph","getInitialGrid","rowCount","state","ROW_COUNT","colCount","COLUMN_COUNT","initialGrid","currentRow","createNode","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","abs","isNode","mouseIsPressed","isRunning","isStartNode","isFinishNode","isWallNode","currRow","currCol","handleMouseDown","bind","handleMouseLeave","toggleIsRunning","setState","isGridClear","document","getElementById","newGrid","getNewGridWithWallToggled","clearGrid","nodeClassName","slice","algo","nextNodesStack","currentNode","nextNode","bfs","pop","dfs","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","animate","animateShortestPath","clearWalls","visualize","onMouseLeave","rowIdx","nodeIdx","handleMouseEnter","handleMouseUp","newNode","Home","algoBackground","App","path","element","ReactDOM","render"],"mappings":"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","file":"static/js/main.454582b3.chunk.js","sourcesContent":["import React from 'react'\r\nimport Nav from 'react-bootstrap/Nav'\r\nimport Navbar from 'react-bootstrap/Navbar'\r\nimport { NavLink, Link } from 'react-router-dom'\r\nimport './Header.css'\r\n\r\n\r\nconst Header = () => (\r\n  <div className=\"header\">\r\n    <Navbar>\r\n      <Navbar.Brand><h1>Algorithm Fun</h1></Navbar.Brand>\r\n        <Nav>\r\n          <NavLink className=\"nav-link\" to=\"/\">Home</NavLink>\r\n          <NavLink className=\"nav-link\" to=\"/sort\">Sorter</NavLink>\r\n          <NavLink className=\"nav-link\" to=\"/path\">PathFinder\r\n          </NavLink>\r\n          <a className=\"nav-link\" href=\"https://robert-a-johnston.github.io/\"\r\n            target=\"_blank\" rel=\"noreferrer\">Portfolio</a>\r\n        </Nav>     \r\n    </Navbar>\r\n  </div>\r\n)\r\n\r\nexport default Header\r\n","export function getMergeSortAnimations(arr) {\r\n  const copyArray = [...arr]\r\n  const len = copyArray.length\r\n  const tempArray = Array(len)\r\n  const animations = []\r\n  mergeSortHelper(copyArray, tempArray, 0, len - 1, animations)\r\n  return animations\r\n}\r\n\r\nfunction mergeSortHelper(arr, tempArray, left, right, animations) {\r\n  if (right <= left) return\r\n  const mid = left + Math.floor((right - left) / 2)\r\n  mergeSortHelper(arr, tempArray, left, mid, animations)\r\n  mergeSortHelper(arr, tempArray, mid + 1, right, animations)\r\n  merge(arr, tempArray, left, mid, right, animations)\r\n}\r\n\r\nfunction merge(arr, tempArray, left, mid, right, animations) {\r\n  for (let i = left; i <= right; i++) tempArray[i] = arr[i]\r\n  let i = left\r\n  let j = mid + 1\r\n  for (let k = left; k <= right; k++) {\r\n    if (i > mid) {\r\n      animations.push([[j], false])\r\n      animations.push([[k, tempArray[j]], true])\r\n      arr[k] = tempArray[j++]\r\n    } else if (j > right) {\r\n      animations.push([[i], false])\r\n      animations.push([[k, tempArray[i]], true])\r\n      arr[k] = tempArray[i++]\r\n    } else if (tempArray[j] < tempArray[i]) {\r\n      animations.push([[i, j], false])\r\n      animations.push([[k, tempArray[j]], true])\r\n      arr[k] = tempArray[j++]\r\n    } else {\r\n      animations.push([[i, j], false])\r\n      animations.push([[k, tempArray[i]], true])\r\n      arr[k] = tempArray[i++]\r\n    }\r\n  }\r\n}","export function quickSortAnimations(arr) {\r\n    // copy the array\r\n    const copyArray = [...arr]\r\n    // create array for animations\r\n    const animations = []\r\n    // run quicksort\r\n    quickSort(copyArray, 0, copyArray.length - 1, animations)\r\n    // return animation array for 'main' \r\n    return animations\r\n  }\r\n  \r\n  function quickSort(arr, start, end, animations) {\r\n    // check that end is > start\r\n    if (end <= start) return\r\n    // get partition value for recursive calls\r\n    const part = partition(arr, start, end, animations)\r\n    // recursive calls to go through all of array\r\n    quickSort(arr, start, part, animations)\r\n    quickSort(arr, part + 1, end, animations)\r\n  }\r\n  \r\n  function partition(arr, start, end, animations) {\r\n    // start pointer\r\n    let i = start\r\n    // end pointer\r\n    let j = end + 1\r\n    // set pivot to first element in arr\r\n    const pivot = arr[start]\r\n    \r\n    // run until break\r\n    while (true) {\r\n      // move right one from start and checks value against pivot\r\n      while (arr[++i] <= pivot) {\r\n        // quit if i gets to end of array\r\n        if (i === end) break\r\n        // add array of [i, false] to animations array\r\n        animations.push([[i], false])\r\n      }\r\n      // moves left one from end and checks pivot\r\n      while (arr[--j] >= pivot) {\r\n        // quit if j gets to start of array\r\n        if (j === start) break\r\n        // add array of [j, false] to animations array\r\n        animations.push([[j], false])\r\n      }\r\n      // quit if end index is < = to start index\r\n      if (j <= i) break\r\n      // add array [[i, arrayValue at j], true]\r\n      animations.push([[i, arr[j]], true])\r\n      // add array [[j, arrayValue at i], true]\r\n      animations.push([[j, arr[i]], true])\r\n      // switch i with j in arr\r\n      swap(arr, i, j)\r\n    }\r\n\r\n    // add array to animation [[start index, arrayValue at j],\r\n    // true]\r\n    animations.push([[start, arr[j]], true])\r\n    // add array to animation [[j index, arrayValue at start index],\r\n    // true]\r\n    animations.push([[j, arr[start]], true])\r\n    // swap start element with jth element\r\n    swap(arr, start, j)\r\n    // return index at j\r\n    return j\r\n  }\r\n\r\n  function swap(arr, index1, index2) {\r\n    // create temp value and set to index1 value\r\n    const temp = arr[index1]\r\n    // change index1 value to index2 value\r\n    arr[index1] = arr[index2]\r\n    // set index2 value to temp value that was index1 old value\r\n    arr[index2] = temp\r\n  }","export function bubbleSortAnimations(arr) {\r\n  // copy the array\r\n  const copyArray = [...arr]\r\n  const animations = []\r\n\r\n  bubbleSort(copyArray, animations)\r\n\r\n  return animations\r\n}\r\n\r\nfunction bubbleSort(arr, animations) {\r\n  let i, j\r\n  let len = arr.length\r\n  let isSwapped = false\r\n\r\n  for (i = 0; i < len; i++){\r\n    isSwapped = false\r\n    for (j = 0; j < len; j ++){\r\n      \r\n      if(arr[j] > arr[j + 1]) {\r\n        animations.push([[j, arr[j + 1]], true])\r\n        animations.push([[j + 1, arr[j]], true])\r\n        swap(arr, j, j + 1)\r\n        isSwapped = true\r\n        \r\n      } \r\n        animations.push([[j], false])\r\n    }\r\n    if(!isSwapped){\r\n      break\r\n    }\r\n  }\r\n  return j\r\n}\r\nfunction swap(arr, index1, index2) {\r\n  // create temp value and set to index1 value\r\n  const temp = arr[index1]\r\n  // change index1 value to index2 value\r\n  arr[index1] = arr[index2]\r\n  // set index2 value to temp value that was index1 old value\r\n  arr[index2] = temp\r\n}\r\n","import { shuffleArray } from \"./ShuffleArray\"\r\nimport { resetArrayColour } from \"./ResetArrayColor\"\r\nconst MAX_VALUE = 55\r\nconst MIN_VALUE = 5\r\nconst ARRAY_LENGTH = MAX_VALUE - MIN_VALUE\r\n\r\n// Create new array of integers\r\nexport function createArray(containerRef, intArr) {\r\n  // resets to original color when new array created\r\n  resetArrayColour(containerRef, intArr)\r\n  // variables for use to create array of\r\n  // numbers from minValue to end of arrayLength\r\n  const tempArr = []\r\n  let arrayValue = MIN_VALUE\r\n  // create array of values from min to max\r\n  for(let i = 0; i < ARRAY_LENGTH; i++) {\r\n    // add array value to temp array\r\n    tempArr.push(arrayValue)\r\n    // add 1 to arrayValue\r\n    arrayValue++\r\n  }\r\n  // shuffle values in array\r\n  shuffleArray(tempArr)\r\n  return tempArr\r\n}\r\n\r\nexport function getArrayLength() {\r\n  return MAX_VALUE - MIN_VALUE\r\n}\r\n\r\nexport function getMinValue(){\r\n  return MIN_VALUE\r\n}\r\n","// Clears colors when array is reset\r\nexport function resetArrayColour(containerRef, intArr) {\r\n    const arrayBars = containerRef.current.children\r\n    // changes bar style back to original color by removing\r\n    // colors after sorting\r\n    for (let i = 0; i < intArr.length; i++) {\r\n      const arrayBarStyle = arrayBars[i].style\r\n      arrayBarStyle.backgroundColor = ''\r\n    }\r\n  }","\r\n// Fisher-Yates algorithm to randomize array items\r\nexport function shuffleArray(array) {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1))\r\n    const temp = array[i]\r\n    array[i] = array[j]\r\n    array[j] = temp\r\n  }\r\n}","export default __webpack_public_path__ + \"static/media/quickSortAlgo.59d510c4.JPG\";","\r\nimport React from 'react'\r\nimport './QuickSortInfo.css'\r\nimport quickSortAlgo from '../../algo-images/quickSortAlgo.JPG'\r\n\r\nexport default function QuickSortInfo() {\r\n  return (\r\n    <div>\r\n      <h2>QuickSort Algorithm</h2>\r\n      \r\n      <div className=\"container\">\r\n\r\n        <div className=\"algo-info\">\r\n          <h3><u>Time/Space Complexity</u></h3>\r\n          <ul>\r\n            <li>Average Time: O(n log(n))</li>  \r\n            <li>Worst Time: O(n^2)</li>\r\n            <li>Space: O(log(n))</li>\r\n          </ul>\r\n\r\n          <h4><u>Steps for QuickSort</u></h4>\r\n          <ol>\r\n            <li>Select pivot.  Can select any element(first/last/middle)</li>\r\n            <li>Start left pointer at first element and right pointer at last element.</li>\r\n            <li>Compare left pointer element with pivot element.</li>\r\n            <li>While left pointer element is less than pivot shift left pointer right one element.</li>\r\n            <li>While right pointer element is greater than pivot shift right pointer left one element.</li>\r\n            <li>Check if left pointer element is greater than right pointer element.</li>\r\n            <li>If left element is less than right pointer element swap left and right pointer values.</li>\r\n            <li>Add one to left pointer and subtract one from right pointer</li>\r\n            <li>If the index of the left pointer is less than the index of the right \r\n              pointer repeat the process. If not return the index of the left pointer.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n      <div className=\"algo-pic\">\r\n            <img className=\"quicksort-img\" src={quickSortAlgo} alt=\"Quick Sort Algorithm\"></img>     \r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","export default __webpack_public_path__ + \"static/media/mergeSortAlgo.b0ceeec9.JPG\";","import React from 'react'\r\nimport './MergeSort.css'\r\nimport mergeSortAlgo from '../../algo-images/mergeSortAlgo.JPG'\r\n\r\nexport default function MergeSortInfo() {\r\n  return (\r\n    <div>\r\n      <h2>MergeSort Algorithm</h2>\r\n\r\n      <div className=\"container\">\r\n        \r\n          \r\n        <div className=\"algo-info\">\r\n\r\n          <h3><u>Time/Space Complexity</u></h3>\r\n          <ul>\r\n            <li>Average Time: O(n log(n))</li>  \r\n            <li>Worst Time: O(n log(n))</li>\r\n            <li>Space: O(n)</li>\r\n          </ul>\r\n      \r\n          <h4><u>Steps for MergeSort</u></h4>\r\n          <ol>\r\n            <li>Split given array in half.</li>\r\n            <li>Recursively divide sub-arrays in half until you are left with an array \r\n              with a single value.\r\n            </li>\r\n            <li>Merge single value sub-arrays so that they are sorted.</li>\r\n            <li>Repeat merging sub-arrays and sorting until all values are in sorted array.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n      <div className=\"algo-pic\">\r\n        <img className=\"merge-sort-img\" src={mergeSortAlgo} alt=\"Merge Sort Algorithm\"></img>     \r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","export default __webpack_public_path__ + \"static/media/bubbleSortAlgo.8146cbc2.JPG\";","\r\nimport React from 'react'\r\nimport './BubbleSortInfo.css'\r\nimport bubbleSortAlgo from '../../algo-images/bubbleSortAlgo.JPG'\r\n\r\nexport default function BubbleSortInfo() {\r\n  return (\r\n    <div>\r\n      <h2>BubbleSort Algorithm</h2>\r\n      \r\n      <div className=\"container\">\r\n\r\n        <div className=\"algo-info\">\r\n          <h3><u>Time/Space Complexity</u></h3>\r\n          <ul>\r\n            <li>Average Time: O(n^2)</li>  \r\n            <li>Worst Time: O(n^2)</li>\r\n            <li>Space: O(1)</li>\r\n          </ul>\r\n\r\n          <h4><u>Steps for BubbleSort</u></h4>\r\n          <ol>\r\n            <li>Start at first item in unsorted array.</li>\r\n            <li>Check if the next item is less than first item.</li>\r\n            <li>If the next item is less than the first swap items.</li>\r\n            <li>Continue checking if next value is greater or less than and switching when\r\n              value is less than.\r\n            </li>\r\n            <li>Continue iterating through all of the items in the array until sorted.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"algo-pic\">\r\n            <img className=\"bubble-sort-img\" src={bubbleSortAlgo} alt=\"Bubble Sort Algorithm\"></img>     \r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","import React, { useState, useEffect, useRef } from 'react'\r\nimport { getMergeSortAnimations } from '../../algorithms/sorts/MergeSort'\r\nimport { quickSortAnimations } from '../../algorithms/sorts/QuickSort'\r\nimport { bubbleSortAnimations } from '../../algorithms/sorts/BubbleSort'\r\nimport { createArray, getArrayLength, getMinValue } from './create-array-functions/CreateArray'\r\nimport QuickSortInfo from '../../algorithms/info/quick-sort/QuickSortInfo'\r\nimport MergeSortInfo from '../../algorithms/info/merge-sort/MergeSort'\r\nimport BubbleSortInfo from '../../algorithms/info/bubble-sort/BubbleSortInfo'\r\nimport './SortDisplay.css'\r\n\r\nconst DELAY = 15\r\nconst PRIMARY_COLOR = 'green'\r\nconst SECONDARY_COLOR = 'red'\r\n\r\n\r\n\r\nexport default function SortDisplay() {\r\n  const [intArr, setIntArr] = useState([])\r\n  const [info, setInfo] = useState('')\r\n  const containerRef = useRef(null)\r\n  const [disabled, setDisabled] = useState(false)\r\n  const [disableCreate, setDisableCreate] = useState(false)\r\n  \r\n \r\n  // on load creates new array\r\n  useEffect(() => setIntArr(createArray(containerRef, intArr)), [])\r\n\r\n\r\n  // ANIMATION FUNCTIONS\r\n  function animateArrayUpdate(animations) { \r\n    animations.forEach(([comparison, swapped], index) => {\r\n      setTimeout(() => {\r\n        if (!swapped) {\r\n          if (comparison.length === 2) {\r\n            const [i, j] = comparison\r\n            animateArrayAccess(i)\r\n            animateArrayAccess(j)\r\n          } else {\r\n            const [i] = comparison\r\n            animateArrayAccess(i)\r\n          }\r\n        } else {\r\n          setIntArr((prevArr) => {\r\n            const [k, newValue] = comparison\r\n            const newArr = [...prevArr]\r\n            newArr[k] = newValue\r\n            return newArr\r\n          })\r\n        }\r\n      }, index * DELAY)\r\n    })\r\n    setTimeout(() => {\r\n      animateSortedArray()\r\n    }, animations.length * DELAY)\r\n  }\r\n\r\n  function animateArrayAccess(index) {\r\n    \r\n    const arrayBars = containerRef.current.children\r\n    const arrayBarStyle = arrayBars[index].style\r\n    setTimeout(() => {\r\n      arrayBarStyle.backgroundColor = SECONDARY_COLOR\r\n    }, DELAY)\r\n    setTimeout(() => {\r\n      arrayBarStyle.backgroundColor = ''\r\n    }, DELAY * 2)\r\n  }\r\n  // sets color to green when sorted\r\n  function animateSortedArray() {\r\n    \r\n    const arrayBars = containerRef.current.children\r\n    console.log(arrayBars)\r\n    for (let i = 0; i < arrayBars.length -1; i++) {\r\n      const arrayBarStyle = arrayBars[i].style\r\n      setTimeout(\r\n        () => (arrayBarStyle.backgroundColor = PRIMARY_COLOR),\r\n        i * DELAY,\r\n      )\r\n    }\r\n    setTimeout(() => {\r\n     setDisableCreate(false)\r\n    }, arrayBars.length * DELAY)\r\n  }\r\n\r\n  // ON CLICK FUNCTIONS\r\n  function onClickSetIntArr() {\r\n    setInfo('')\r\n    setDisabled(false)\r\n    setIntArr(createArray(containerRef, intArr))\r\n    setDisableCreate(false)\r\n  }\r\n\r\n  \r\n\r\n  // SORTING FUNCTIONS\r\n  // mergeSort\r\n  function mergeSort() {\r\n    setDisabled(true)\r\n    setDisableCreate(true)\r\n    setInfo(MergeSortInfo)\r\n    const animations = getMergeSortAnimations(intArr)\r\n    animateArrayUpdate(animations)\r\n  }\r\n  // quickSort\r\n  function quickSort() {\r\n    setDisabled(true)\r\n    setDisableCreate(true)\r\n    setInfo(QuickSortInfo)\r\n    const animations = quickSortAnimations(intArr)\r\n    animateArrayUpdate(animations)\r\n    \r\n  }\r\n  function bubbleSort() {\r\n    setDisabled(true)\r\n    setDisableCreate(true)\r\n    setInfo(BubbleSortInfo)\r\n    const animations = bubbleSortAnimations(intArr)\r\n    animateArrayUpdate(animations)\r\n    \r\n  }\r\n\r\n\r\n  return (\r\n    <div className=\"display-container\">\r\n      <div className=\"button-container\">\r\n        <button \r\n          className=\"button\" \r\n          id=\"create-array\"\r\n          onClick={() => onClickSetIntArr()}\r\n          disabled={disableCreate}>\r\n            Create/Reset Array\r\n        </button>\r\n        <button\r\n          className=\"button\"\r\n          id=\"merge-sort\"\r\n          onClick={mergeSort}\r\n          disabled={disabled}>\r\n            MergeSort\r\n        </button>\r\n        <button\r\n          className=\"button\"\r\n          id=\"quick-sort\"\r\n          onClick={quickSort}\r\n          disabled={disabled}>\r\n            QuickSort\r\n          </button>  \r\n          <button\r\n          className=\"button\"\r\n          id=\"bubble-sort\"\r\n          onClick={bubbleSort}\r\n          disabled={disabled}>\r\n            BubbleSort\r\n          </button>  \r\n      </div>\r\n      \r\n      <div className=\"array-bar-container\" ref={containerRef}>\r\n        {intArr.map((barHeight, index) => (\r\n          <div\r\n          className=\"array-bar\"\r\n          style={{\r\n            height: `${barHeight}Vmin`,\r\n            width: `${100 / getArrayLength()}vw`,\r\n            color: 'white',\r\n          }}\r\n          key={index}\r\n          >{barHeight - getMinValue() + 1}</div>\r\n        ))}\r\n        <div \r\n        className=\"array-bar-topper\"\r\n        style={{height: `55vmin`,\r\n        width:`${100 / getArrayLength()}vw`}}></div>\r\n      </div>\r\n      <code className=\"info\">{info}</code>\r\n    </div>\r\n  )\r\n}\r\n","import React, {Component} from 'react'\r\n\r\nimport './Node.css'\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props\r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : ''\r\n\r\n    return (\r\n      <td\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></td>\r\n    )\r\n  }\r\n}","// Performs Dijkstra's algorithm returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = []\r\n  startNode.distance = 0\r\n  const unvisitedNodes = getAllNodes(grid)\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes)\r\n    const closestNode = unvisitedNodes.shift()\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder\r\n    closestNode.isVisited = true\r\n    visitedNodesInOrder.push(closestNode)\r\n    if (closestNode === finishNode) return visitedNodesInOrder\r\n    updateUnvisitedNeighbors(closestNode, grid)\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid)\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1\r\n    neighbor.previousNode = node\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = []\r\n  const {col, row} = node\r\n  if (row > 0) neighbors.push(grid[row - 1][col])\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col])\r\n  if (col > 0) neighbors.push(grid[row][col - 1])\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1])\r\n  return neighbors.filter(neighbor => !neighbor.isVisited)\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = []\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node)\r\n    }\r\n  }\r\n  return nodes\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = []\r\n  let currentNode = finishNode\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode)\r\n    currentNode = currentNode.previousNode\r\n  }\r\n  return nodesInShortestPathOrder\r\n}","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function AStar(grid, startNode, finishNode) {\r\n  console.log('in astar')\r\n  // array of all visited nodes\r\n  const visitedNodesInOrder = [];\r\n  // set start node distance to 0\r\n  startNode.distance = 0;\r\n  // array of all unvisited nodes\r\n  const unvisitedNodes = getAllNodes(grid); \r\n  \r\n  // unvisitedNodes.length = 15 * 15 or size of graph\r\n  while (unvisitedNodes.length) {\r\n    // get array of unvisited nodes by  sorted by distance\r\n    sortByDistance(unvisitedNodes);\r\n    // pop top node from sorted unvisited nodes array\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (!closestNode.isWall) {\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      \r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n}\r\n\r\n// creates and returns array of all nodes\r\nfunction getAllNodes(grid) {\r\n  // nodes array\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      console.log(node)\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction sortByDistance(unvisitedNodes) {\r\n  // return sorted array of unvisited nodes by distance\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}","\r\nimport React from 'react'\r\nimport './DijkstraInfo.css'\r\n//import bubbleSortAlgo from '../../algo-images/bubbleSortAlgo.JPG'\r\n\r\nexport default function DijkstraInfo() {\r\n  return (\r\n    <div>\r\n      <h2><a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\" target=\"_blank\" rel=\"noreferrer\">\r\n        Dijkstra's Algorithm</a></h2>\r\n      \r\n      <div className=\"container\">\r\n        <div className=\"algo-info\">\r\n          <h3>Time/Space Complexity</h3>\r\n          <p>* Depends on Implementation(V = vertices E = edges)</p>\r\n          <ul>\r\n            <li>Average Time: O(|E| log|V|))</li>  \r\n            <li>Worst Time: O(|V|^2)</li>\r\n            <li>Worst Space: O(|V| + |E|)</li>\r\n          </ul>\r\n          <h3>Requirements</h3>\r\n          <ul>\r\n            <li>Can only have positive weights.</li>\r\n          </ul>\r\n          <h4>Steps for Dijkstra's Algorithm</h4>\r\n          <ol>\r\n            <li>Set all vertices distances = infinity except for the \r\n              source vertex, set the source distance = 0.</li>\r\n            <li>Push the source vertex in a min-priority queue in the \r\n              form (distance , vertex), as the comparison in the min-priority \r\n              queue will be according to vertices distances.</li>\r\n            <li>Pop the vertex with the minimum distance from the priority \r\n              queue (at first the popped vertex = source).</li>\r\n            <li>Update the distances of the connected vertices to the popped \r\n              vertex in case of \"current vertex distance + edge weight less \r\n              than next vertex distance\", then push the vertex\r\n              with the new distance to the priority queue.\r\n            </li>\r\n            <li>If the popped vertex is visited before, just continue without using it.</li>\r\n            <li>Apply the same algorithm again until the priority queue is empty.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","\r\nimport React from 'react'\r\nimport './AstarInfo.css'\r\n\r\n\r\nexport default function AstarInfo() {\r\n  return (\r\n    <div>\r\n      <h2><a href=\"https://en.wikipedia.org/wiki/A*_search_algorithm\" target=\"_blank\" rel=\"noreferrer\">\r\n        A * Algorithm</a></h2>\r\n      \r\n      <div className=\"container\">\r\n        <div className=\"algo-info\">\r\n          <h3>Time/Space Complexity</h3>\r\n          <p>* Depends on Implementation.  E = # of edges, V = # of vertices</p>\r\n          <ul>\r\n            <li>Worst Time: O(E)</li>\r\n            <li>Worst Space: O(V)</li>\r\n          </ul>\r\n\r\n          <h4>Steps for A * Algorithm</h4>\r\n          <p>* Given a grid with many obstacles and a starting point and ending point </p>\r\n          <p>* g = the movement cost to move from the starting point to a given square on the grid,\r\n            following the path generated to get there.\r\n          </p>\r\n          <p>* h = the estimated movement cost to move from a given square on the grid to the final\r\n            destination.  (Sometimes referred to as the heuristic or smart guess.)\r\n          </p>\r\n          <p>* f = the sum of g and h</p>\r\n          <ol type=\"1\">\r\n            <li>Create two lists named open and closed.</li>\r\n            <li>Put the starting node on the open list(can leave its f\r\n              at 0)\r\n            </li>\r\n            <li>While the open list is not empty</li>\r\n              <ol className=\"while\" type=\"a\"> \r\n                <li>Find the node with the least f on the open list, q.</li>\r\n                <li>Generate q's 8 successors and set their parents to q.</li>\r\n\r\n                <li>For each successor:</li>\r\n                  <ol className=\"for-each\" type=\"i\">\r\n                    <li>If the successor is the goal, stop the search\r\n                      successor.g = q.g + distance between successor and q<br></br>\r\n                      successor.h = distance from goal to successors<br></br>\r\n                      successor.f = successor.g + successor.<br></br>\r\n                    </li>\r\n                    <li>If a node with the same position as successor is in the OPEN list\r\n                      which has a lower f than successor, skip this successor\r\n                    </li>\r\n                    <li>If a node with the same position as successor is in the CLOSED list\r\n                      which has a lower f than successor, skip this successor.  Otherwise, add\r\n                      the node to the open list.  \r\n                    </li>\r\n                    <li>End for loop.</li>\r\n                  </ol>\r\n                <li>Push q on the closed list</li>\r\n                <li>End while loop.</li>\r\n              </ol>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","\r\nimport React from 'react'\r\nimport './BreathFirstSearhInfo.css'\r\n\r\n\r\nexport default function DijkstraInfo() {\r\n  return (\r\n    <div>\r\n      <h2><a\r\n        href=\"https://en.wikipedia.org/wiki/Breadth-first_search\" target=\"_blank\" rel=\"noreferrer\"\r\n         >Breath First Search Algorithm</a></h2>\r\n      \r\n      <div className=\"container\">\r\n        <div className=\"algo-info\">\r\n          <h3>Time/Space Complexity</h3>\r\n          <p>* V = vertices</p>\r\n          <ul>\r\n            <li>Worst Time: O(V)</li>\r\n            <li>Worst Space: O(V)</li>\r\n          </ul>\r\n\r\n          <h4>Steps for Breath First Search</h4>\r\n          <ol>\r\n            <li>Given a graph and start node</li>\r\n            <li>Create QUEUE for vertices visited</li>\r\n            <li>Put first node(start node) in visited queue.</li>\r\n            <li>While queue is not empty.</li>\r\n              <ol type=\"a\">\r\n                <li>Select unvisited adjacent node from first item</li>\r\n                <li>Mark next node as visited by adding it to the queue.</li>\r\n                <li>Repeat above steps until no unvisited adjacent nodes\r\n                  to start node.\r\n                </li>\r\n                <li>Remove first node visited from first node from queue.</li>\r\n                <li>Repeat above steps with adjacent node becoming start node</li>\r\n              </ol>\r\n            <li>End while loop.</li>\r\n          </ol>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","\r\nimport React from 'react'\r\nimport './DepthFirstSearchInfo.css'\r\n\r\n\r\nexport default function DepthFirstSearchInfo() {\r\n  return (\r\n    <div>\r\n      <h2>\r\n        <a href=\"https://en.wikipedia.org/wiki/Depth-first_search#:~:text=Depth%2Dfirst%20search%20(DFS),along%20each%20branch%20before%20backtracking.\"\r\n        target=\"_blank\" rel=\"noreferrer\">\r\n          Depth First Search Algorithm</a></h2>\r\n      \r\n      <div className=\"container\">\r\n        <div className=\"algo-info\">\r\n          <h3>Time/Space Complexity</h3>\r\n          <p>* V = vertices</p>\r\n          <ul>\r\n            <li>Worst Time: O(V)</li>\r\n            <li>Worst Space: O(V)</li>\r\n          </ul>\r\n\r\n          <h4>Steps for Depth First Search</h4>\r\n          <ol>\r\n            <li>Given a graph and start node and end node.</li>\r\n            <li>Create STACK for vertices visited</li>\r\n            <li>Put first node(start node) in visited stack.</li>\r\n            <li>While stack is not empty.</li>\r\n              <ol type=\"a\">\r\n                <li>Select unvisited adjacent node from first item</li>\r\n                <li>Mark node as visited by adding it to the stack.</li>\r\n                <li>Repeat above steps until you reach a node has no \r\n                  unvisited child nodes.\r\n                </li>\r\n                <li>Pop node  with no unvisited child nodes from stack</li>\r\n                <li>Repeat above with each node in stack, until all nodes are\r\n                  visited.\r\n                </li>\r\n                <li> When find end node return stack.  This is the path for \r\n                  nodes traveled to get to end node.\r\n                </li>\r\n              </ol>\r\n            <li>End while loop.</li>\r\n            <li>If you never find the end node return no way to get to node.</li>\r\n          </ol>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","import React, { Component } from 'react'\r\nimport Node from '../node/Node'\r\nimport { dijkstra } from '../../../algorithms/searches/Dijkstra'\r\nimport { AStar } from '../../../algorithms/searches/AStar'\r\nimport { dfs } from '../../../algorithms/searches/DepthFirstSearch'\r\nimport { bfs } from '../../../algorithms/searches/BreathFirstSearch'\r\nimport DijkstraInfo from '../../../algorithms/info/dijkstra/DijkstraInfo'\r\nimport AstarInfo from '../../../algorithms/info/a-star/AstarInfo'\r\nimport BreathFirstSearchInfo from '../../../algorithms/info/breath-first-search/BreathFirstSearchInfo'\r\nimport DepthFirstSearchInfo from '../../../algorithms/info/depth-first-search/DepthFirstSearchInfo'\r\n\r\n\r\nimport './Graph.css'\r\n\r\nexport default class Graph extends Component {\r\n  constructor() {\r\n    super()\r\n    this.state = {\r\n      grid: [],\r\n      START_NODE_ROW: 1,\r\n      FINISH_NODE_ROW: 12,\r\n      START_NODE_COL: 2,\r\n      FINISH_NODE_COL: 12,\r\n      mouseIsPressed: false,\r\n      ROW_COUNT: 15,\r\n      COLUMN_COUNT: 15,\r\n      isRunning: false,\r\n      isStartNode: false,\r\n      isFinishNode: false,\r\n      isWallNode: false, \r\n      currRow: 0,\r\n      currCol: 0,\r\n      info: '',\r\n    }\r\n\r\n    this.handleMouseDown = this.handleMouseDown.bind(this)\r\n    this.handleMouseLeave = this.handleMouseLeave.bind(this)\r\n    this.toggleIsRunning = this.toggleIsRunning.bind(this)\r\n  }\r\n  // occurs when page loads\r\n  // create initial grid and set state\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid()\r\n    this.setState({grid})\r\n  }\r\n\r\n  toggleIsRunning() {\r\n    this.setState({isRunning: !this.state.isRunning})\r\n  }\r\n\r\n\r\n  // Create initial grid with number of rows and columns\r\n  getInitialGrid = (\r\n    rowCount = this.state.ROW_COUNT,\r\n    colCount = this.state.COLUMN_COUNT,\r\n  ) => {\r\n    const initialGrid = []\r\n    for (let row = 0; row < rowCount; row++) {\r\n      const currentRow = []\r\n      for (let col = 0; col < colCount; col++) {\r\n        currentRow.push(this.createNode(row, col))\r\n      }\r\n      initialGrid.push(currentRow)\r\n    }\r\n    return initialGrid\r\n  }\r\n\r\n  // Creates node with row and column values\r\n  createNode = (row, col) => {\r\n    return {\r\n      row,\r\n      col,\r\n      isStart:\r\n        row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n      isFinish:\r\n        row === this.state.FINISH_NODE_ROW &&\r\n        col === this.state.FINISH_NODE_COL,\r\n      distance: Infinity,\r\n      distanceToFinishNode:\r\n        Math.abs(this.state.FINISH_NODE_ROW - row) +\r\n        Math.abs(this.state.FINISH_NODE_COL - col),\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      isNode: true,\r\n    }\r\n  }\r\n\r\n // What happens when you click down on mouse\r\n  handleMouseDown(row, col) {\r\n    // check to make sure animation is not running\r\n    if (!this.state.isRunning) {\r\n      // check to see if grid is clear\r\n      if (this.isGridClear()) {\r\n        // determines if start node\r\n        if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-start'\r\n        ) {\r\n          // selects if click on start node allowing change of start\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isStartNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          })\r\n          // determines of finish node\r\n        } else if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-finish'\r\n        ) {\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isFinishNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          })\r\n        } else {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col)\r\n          this.setState({\r\n            grid: newGrid,\r\n            mouseIsPressed: true,\r\n            isWallNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          })\r\n        }\r\n      } else {\r\n        // resets grid if path search has run and click down on mouse\r\n        this.clearGrid()\r\n      }\r\n    }\r\n  }\r\n\r\n  isGridClear() {\r\n    // traverse rows of grid\r\n    for (const row of this.state.grid) {\r\n      // traverse columns of grid\r\n      for (const node of row) {\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className\r\n        if (\r\n          nodeClassName === 'node node-visited' ||\r\n          nodeClassName === 'node node-shortest-path'\r\n        ) {\r\n          return false\r\n        }\r\n      }\r\n    }\r\n    return true\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.isRunning) {\r\n      if (this.state.mouseIsPressed) {\r\n        const nodeClassName = document.getElementById(`node-${row}-${col}`)\r\n          .className\r\n        if (this.state.isStartNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevStartNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ]\r\n            prevStartNode.isStart = false\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node'\r\n\r\n            this.setState({currRow: row, currCol: col})\r\n            const currStartNode = this.state.grid[row][col]\r\n            currStartNode.isStart = true\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-start'\r\n          }\r\n          this.setState({START_NODE_ROW: row, START_NODE_COL: col})\r\n        } else if (this.state.isFinishNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevFinishNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ]\r\n            prevFinishNode.isFinish = false\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node'\r\n\r\n            this.setState({currRow: row, currCol: col})\r\n            const currFinishNode = this.state.grid[row][col]\r\n            currFinishNode.isFinish = true\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-finish'\r\n          }\r\n          this.setState({FINISH_NODE_ROW: row, FINISH_NODE_COL: col})\r\n        } else if (this.state.isWallNode) {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col)\r\n          this.setState({grid: newGrid})\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseUp(row, col) {\r\n    if (!this.state.isRunning) {\r\n      this.setState({mouseIsPressed: false})\r\n      if (this.state.isStartNode) {\r\n        const isStartNode = !this.state.isStartNode\r\n        this.setState({isStartNode, START_NODE_ROW: row, START_NODE_COL: col})\r\n      } else if (this.state.isFinishNode) {\r\n        const isFinishNode = !this.state.isFinishNode\r\n        this.setState({\r\n          isFinishNode,\r\n          FINISH_NODE_ROW: row,\r\n          FINISH_NODE_COL: col,\r\n        })\r\n      }\r\n      this.getInitialGrid()\r\n    }\r\n  }\r\n\r\n  handleMouseLeave() {\r\n    if (this.state.isStartNode) {\r\n      const isStartNode = !this.state.isStartNode\r\n      this.setState({isStartNode, mouseIsPressed: false})\r\n    } else if (this.state.isFinishNode) {\r\n      const isFinishNode = !this.state.isFinishNode\r\n      this.setState({isFinishNode, mouseIsPressed: false})\r\n    } else if (this.state.isWallNode) {\r\n      const isWallNode = !this.state.isWallNode\r\n      this.setState({isWallNode, mouseIsPressed: false})\r\n      this.getInitialGrid()\r\n    }\r\n  }\r\n\r\n  /******************** Clear Board/Walls ********************/\r\n\r\n  clearGrid() {\r\n    if (!this.state.isRunning) {\r\n      this.setState({info: ''})\r\n      const newGrid = this.state.grid.slice()\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish' &&\r\n            nodeClassName !== 'node node-wall'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node'\r\n            node.isVisited = false\r\n            node.distance = Infinity\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col)\r\n          }\r\n          if (nodeClassName === 'node node-finish') {\r\n            node.isVisited = false\r\n            node.distance = Infinity\r\n            node.distanceToFinishNode = 0\r\n          }\r\n          if (nodeClassName === 'node node-start') {\r\n            node.isVisited = false\r\n            node.distance = Infinity\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col)\r\n            node.isStart = true\r\n            node.isWall = false\r\n            node.previousNode = null\r\n            node.isNode = true\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  clearWalls() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice()\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className\r\n          if (nodeClassName === 'node node-wall') {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node'\r\n            node.isWall = false\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /******************** Create Animations ********************/\r\n  visualize(algo) {\r\n    if (!this.state.isRunning) {\r\n      \r\n      this.clearGrid()\r\n      this.toggleIsRunning()\r\n      const {grid} = this.state\r\n      const startNode =\r\n        grid[this.state.START_NODE_ROW][this.state.START_NODE_COL]\r\n      const finishNode =\r\n        grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL]\r\n      let visitedNodesInOrder\r\n      switch (algo) {\r\n        case 'Dijkstra':\r\n          this.setState({info: <DijkstraInfo></DijkstraInfo>})\r\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode)\r\n          break\r\n        case 'AStar':\r\n          this.setState({info: <AstarInfo></AstarInfo>})\r\n          visitedNodesInOrder = AStar(grid, startNode, finishNode)\r\n          break\r\n        case 'BFS':\r\n          this.setState({info: <BreathFirstSearchInfo></BreathFirstSearchInfo>})\r\n          visitedNodesInOrder = bfs(grid, startNode, finishNode)\r\n          break\r\n        case 'DFS':\r\n          this.setState({info: <DepthFirstSearchInfo></DepthFirstSearchInfo>})\r\n          visitedNodesInOrder = dfs(grid, startNode, finishNode)\r\n          break\r\n        default:\r\n          // should never get here\r\n          break\r\n      }\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode)\r\n      nodesInShortestPathOrder.push('end')\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder)\r\n    }\r\n  }\r\n\r\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder)\r\n        }, 10 * i)\r\n        return\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i]\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className\r\n        if (\r\n          nodeClassName !== 'node node-start' &&\r\n          nodeClassName !== 'node node-finish'\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node node-visited'\r\n        }\r\n      }, 10 * i)\r\n    }\r\n  }\r\n\r\n  /******************** Create path from start to finish ********************/\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      if (nodesInShortestPathOrder[i] === 'end') {\r\n        setTimeout(() => {\r\n          this.toggleIsRunning()\r\n        }, i * 50)\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i]\r\n          const nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node node-shortest-path'\r\n          }\r\n        }, i * 40)\r\n      }\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const {grid, mouseIsPressed} = this.state\r\n    return (\r\n\r\n      <div className=\"main-container\">\r\n        <div className=\"left-side\">\r\n         \r\n          <div className=\"info-box\">{this.state.info}</div>\r\n        </div>\r\n        <div className=\"button-container-graph\">\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-danger\"\r\n            onClick={() => this.clearGrid()}>\r\n            Clear Grid\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-warning\"\r\n            onClick={() => this.clearWalls()}>\r\n            Clear Walls\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => this.visualize('Dijkstra')}>\r\n            Dijkstra's\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => this.visualize('AStar')}>\r\n            A*\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => this.visualize('BFS')}>\r\n            Breath First Search\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => this.visualize('DFS')}>\r\n            Depth First Search\r\n          </button>\r\n        \r\n\r\n        <table\r\n          className=\"grid-container\"\r\n          onMouseLeave={() => this.handleMouseLeave()}>\r\n          <tbody className=\"grid\">\r\n            {grid.map((row, rowIdx) => {\r\n              return (\r\n                <tr key={rowIdx}>\r\n                  {row.map((node, nodeIdx) => {\r\n                    const {row, col, isFinish, isStart, isWall} = node\r\n                    return (\r\n                      <Node\r\n                        key={nodeIdx}\r\n                        col={col}\r\n                        isFinish={isFinish}\r\n                        isStart={isStart}\r\n                        isWall={isWall}\r\n                        mouseIsPressed={mouseIsPressed}\r\n                        onMouseDown={(row, col) =>\r\n                          this.handleMouseDown(row, col)\r\n                        }\r\n                        onMouseEnter={(row, col) =>\r\n                          this.handleMouseEnter(row, col)\r\n                        }\r\n                        onMouseUp={() => this.handleMouseUp(row, col)}\r\n                        row={row}></Node>\r\n                    )\r\n                  })}\r\n                </tr>\r\n              )\r\n            })}\r\n          </tbody>\r\n        </table>\r\n          <div className=\"instructions-container\">\r\n            <h4>Instructions</h4>\r\n            <ul className=\"instructions-list\">\r\n              <li>You  can move the start an end nodes by clicking and dragging the nodes within\r\n                the grid.\r\n              </li>\r\n              <li>You can create walls by clicking empty squares on the grid.  They will turn \r\n                black.</li>\r\n            </ul>\r\n          </div> \r\n        </div>     \r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n/******************** Create Walls ********************/\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\r\n  const newGrid = grid.slice()\r\n  const node = newGrid[row][col]\r\n  if (!node.isStart && !node.isFinish && node.isNode) {\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    }\r\n    newGrid[row][col] = newNode\r\n  }\r\n  return newGrid\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called after the path-finding methods.\r\nfunction getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = []\r\n  let currentNode = finishNode\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode)\r\n    currentNode = currentNode.previousNode\r\n  }\r\n  return nodesInShortestPathOrder\r\n}","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  let nextNodesStack = [startNode];\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.shift();\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // return visitedNodesInOrder;\r\n}","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const nextNodesStack = [];\r\n  nextNodesStack.push(startNode);\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.pop();\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","export default __webpack_public_path__ + \"static/media/algoBackground.1ab6939a.jpg\";","import React from 'react'\r\nimport './Home.css'\r\nimport algoBackground from './algoBackground.jpg'\r\n\r\nexport default function Home() {\r\n  return (\r\n    <div>\r\n      <img src={algoBackground} alt='math'/>\r\n    </div>\r\n  )\r\n}\r\n","import React, {Fragment} from 'react';\r\nimport { Routes, Route } from 'react-router-dom'\r\nimport './App.css';\r\nimport Header from './components/header/Header'\r\nimport SortDisplay from './components/sort-display/SortDisplay';\r\nimport Graph from './components/path-finder/graph/Graph'\r\nimport Home from './components/home/Home';\r\n\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Fragment>\r\n        <Header/>\r\n        <main>\r\n        <Routes>\r\n          <Route\r\n            path='/'\r\n            element={<Home/>}/>\r\n            \r\n          <Route\r\n            path='/sort'\r\n            element={<SortDisplay/>}/>\r\n        \r\n          <Route\r\n            path='/path'\r\n            element={<Graph/>}/>\r\n          </Routes>\r\n        </main>\r\n      </Fragment>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport { BrowserRouter } from 'react-router-dom'\r\n\r\n\r\nReactDOM.render(\r\n  <BrowserRouter>\r\n    <App/>\r\n  </BrowserRouter>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}