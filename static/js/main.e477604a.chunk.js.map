{"version":3,"sources":["components/header/Header.js","algorithms/sorts/MergeSort.js","algorithms/sorts/QuickSort.js","algorithms/sorts/BubbleSort.js","components/sort-display/create-array-functions/CreateArray.js","components/sort-display/create-array-functions/ResetArrayColor.js","components/sort-display/create-array-functions/ShuffleArray.js","algorithms/algo-images/quickSortAlgo.JPG","algorithms/info/quick-sort/QuickSortInfo.js","algorithms/algo-images/mergeSortAlgo.JPG","algorithms/info/merge-sort/MergeSort.js","algorithms/algo-images/bubbleSortAlgo.JPG","algorithms/info/bubble-sort/BubbleSortInfo.js","components/sort-display/SortDisplay.js","components/path-finder/node/Node.js","algorithms/searches/Dijkstra.js","algorithms/searches/AStar.js","algorithms/info/dijkstra/DijkstraInfo.js","algorithms/info/a-star/AstarInfo.js","algorithms/info/breath-first-search/BreathFirstSearchInfo.js","algorithms/info/depth-first-search/DepthFirstSearchInfo.js","components/path-finder/graph/Graph.js","algorithms/searches/BreathFirstSearch.js","algorithms/searches/DepthFirstSearch.js","App.js","index.js"],"names":["Header","className","Navbar","Brand","Nav","to","onClick","e","stopPropagation","getMergeSortAnimations","arr","copyArray","len","length","animations","mergeSortHelper","Array","tempArray","left","right","mid","Math","floor","i","j","k","push","merge","quickSortAnimations","quickSort","start","end","part","pivot","swap","partition","index1","index2","temp","bubbleSortAnimations","isSwapped","bubbleSort","createArray","containerRef","intArr","arrayBars","current","children","style","backgroundColor","resetArrayColour","tempArr","arrayValue","MAX_VALUE","array","random","shuffleArray","QuickSortInfo","src","quickSortAlgo","alt","MergeSortInfo","mergeSortAlgo","BubbleSortInfo","bubbleSortAlgo","DELAY","PRIMARY_COLOR","SortDisplay","useState","setIntArr","info","setInfo","useRef","disabled","setDisabled","disableCreate","setDisableCreate","animateArrayUpdate","forEach","index","comparison","swapped","setTimeout","prevArr","newValue","newArr","animateArrayAccess","console","log","arrayBarStyle","animateSortedArray","useEffect","id","ref","map","barHeight","height","width","color","Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","AStar","sortByDistance","distanceToFinishNode","DijkstraInfo","AstarInfo","DepthFirstSearchInfo","Graph","getInitialGrid","rowCount","state","ROW_COUNT","colCount","COLUMN_COUNT","initialGrid","currentRow","createNode","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","abs","isNode","mouseIsPressed","isRunning","isStartNode","isFinishNode","isWallNode","currRow","currCol","handleMouseDown","bind","handleMouseLeave","toggleIsRunning","setState","isGridClear","document","getElementById","newGrid","getNewGridWithWallToggled","clearGrid","nodeClassName","slice","algo","nextNodesStack","currentNode","nextNode","bfs","pop","dfs","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","animate","animateShortestPath","type","clearWalls","visualize","onMouseLeave","rowIdx","nodeIdx","handleMouseEnter","handleMouseUp","newNode","App","path","element","ReactDOM","render"],"mappings":"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","file":"static/js/main.e477604a.chunk.js","sourcesContent":["import React from 'react'\r\nimport Nav from 'react-bootstrap/Nav'\r\nimport Navbar from 'react-bootstrap/Navbar'\r\nimport { NavLink, Link } from 'react-router-dom'\r\nimport './Header.css'\r\n\r\n\r\nconst Header = () => (\r\n  <div className=\"header\">\r\n    <Navbar>\r\n      <Navbar.Brand><h1>Algorithm Fun</h1></Navbar.Brand>\r\n        <Nav>\r\n          <NavLink className=\"nav-link\" to=\"algorithm-demo/\">Home</NavLink>\r\n          <NavLink className=\"nav-link\" to=\"algorithm-demo/sort\">Sorter</NavLink>\r\n          <NavLink className=\"nav-link\" to=\"algorithm-demo/path\">\r\n            <span className=\"span-link\" onClick= {\r\n              e=> { e.stopPropagation()}\r\n            }>PathFinder</span>\r\n          </NavLink>\r\n        </Nav>\r\n        \r\n    </Navbar>\r\n  </div>\r\n)\r\n\r\nexport default Header\r\n","export function getMergeSortAnimations(arr) {\r\n  const copyArray = [...arr]\r\n  const len = copyArray.length\r\n  const tempArray = Array(len)\r\n  const animations = []\r\n  mergeSortHelper(copyArray, tempArray, 0, len - 1, animations)\r\n  return animations\r\n}\r\n\r\nfunction mergeSortHelper(arr, tempArray, left, right, animations) {\r\n  if (right <= left) return\r\n  const mid = left + Math.floor((right - left) / 2)\r\n  mergeSortHelper(arr, tempArray, left, mid, animations)\r\n  mergeSortHelper(arr, tempArray, mid + 1, right, animations)\r\n  merge(arr, tempArray, left, mid, right, animations)\r\n}\r\n\r\nfunction merge(arr, tempArray, left, mid, right, animations) {\r\n  for (let i = left; i <= right; i++) tempArray[i] = arr[i]\r\n  let i = left\r\n  let j = mid + 1\r\n  for (let k = left; k <= right; k++) {\r\n    if (i > mid) {\r\n      animations.push([[j], false])\r\n      animations.push([[k, tempArray[j]], true])\r\n      arr[k] = tempArray[j++]\r\n    } else if (j > right) {\r\n      animations.push([[i], false])\r\n      animations.push([[k, tempArray[i]], true])\r\n      arr[k] = tempArray[i++]\r\n    } else if (tempArray[j] < tempArray[i]) {\r\n      animations.push([[i, j], false])\r\n      animations.push([[k, tempArray[j]], true])\r\n      arr[k] = tempArray[j++]\r\n    } else {\r\n      animations.push([[i, j], false])\r\n      animations.push([[k, tempArray[i]], true])\r\n      arr[k] = tempArray[i++]\r\n    }\r\n  }\r\n}","export function quickSortAnimations(arr) {\r\n    // copy the array\r\n    const copyArray = [...arr]\r\n    // create array for animations\r\n    const animations = []\r\n    // run quicksort\r\n    quickSort(copyArray, 0, copyArray.length - 1, animations)\r\n    // return animation array for 'main' \r\n    return animations\r\n  }\r\n  \r\n  function quickSort(arr, start, end, animations) {\r\n    // check that end is > start\r\n    if (end <= start) return\r\n    // get partition value for recursive calls\r\n    const part = partition(arr, start, end, animations)\r\n    // recursive calls to go through all of array\r\n    quickSort(arr, start, part, animations)\r\n    quickSort(arr, part + 1, end, animations)\r\n  }\r\n  \r\n  function partition(arr, start, end, animations) {\r\n    // start pointer\r\n    let i = start\r\n    // end pointer\r\n    let j = end + 1\r\n    // set pivot to first element in arr\r\n    const pivot = arr[start]\r\n    \r\n    // run until break\r\n    while (true) {\r\n      // move right one from start and checks value against pivot\r\n      while (arr[++i] <= pivot) {\r\n        // quit if i gets to end of array\r\n        if (i === end) break\r\n        // add array of [i, false] to animations array\r\n        animations.push([[i], false])\r\n      }\r\n      // moves left one from end and checks pivot\r\n      while (arr[--j] >= pivot) {\r\n        // quit if j gets to start of array\r\n        if (j === start) break\r\n        // add array of [j, false] to animations array\r\n        animations.push([[j], false])\r\n      }\r\n      // quit if end index is < = to start index\r\n      if (j <= i) break\r\n      // add array [[i, arrayValue at j], true]\r\n      animations.push([[i, arr[j]], true])\r\n      // add array [[j, arrayValue at i], true]\r\n      animations.push([[j, arr[i]], true])\r\n      // switch i with j in arr\r\n      swap(arr, i, j)\r\n    }\r\n\r\n    // add array to animation [[start index, arrayValue at j],\r\n    // true]\r\n    animations.push([[start, arr[j]], true])\r\n    // add array to animation [[j index, arrayValue at start index],\r\n    // true]\r\n    animations.push([[j, arr[start]], true])\r\n    // swap start element with jth element\r\n    swap(arr, start, j)\r\n    // return index at j\r\n    return j\r\n  }\r\n\r\n  function swap(arr, index1, index2) {\r\n    // create temp value and set to index1 value\r\n    const temp = arr[index1]\r\n    // change index1 value to index2 value\r\n    arr[index1] = arr[index2]\r\n    // set index2 value to temp value that was index1 old value\r\n    arr[index2] = temp\r\n  }","export function bubbleSortAnimations(arr) {\r\n  // copy the array\r\n  const copyArray = [...arr]\r\n  const animations = []\r\n\r\n  bubbleSort(copyArray, animations)\r\n\r\n  return animations\r\n}\r\n\r\nfunction bubbleSort(arr, animations) {\r\n  let i, j\r\n  let len = arr.length\r\n  let isSwapped = false\r\n\r\n  for (i = 0; i < len; i++){\r\n    isSwapped = false\r\n    for (j = 0; j < len; j ++){\r\n      \r\n      if(arr[j] > arr[j + 1]) {\r\n        animations.push([[j, arr[j + 1]], true])\r\n        animations.push([[j + 1, arr[j]], true])\r\n        swap(arr, j, j + 1)\r\n        isSwapped = true\r\n        \r\n      } \r\n        animations.push([[j], false])\r\n    }\r\n    if(!isSwapped){\r\n      break\r\n    }\r\n  }\r\n  return j\r\n}\r\nfunction swap(arr, index1, index2) {\r\n  // create temp value and set to index1 value\r\n  const temp = arr[index1]\r\n  // change index1 value to index2 value\r\n  arr[index1] = arr[index2]\r\n  // set index2 value to temp value that was index1 old value\r\n  arr[index2] = temp\r\n}\r\n","import { shuffleArray } from \"./ShuffleArray\"\r\nimport { resetArrayColour } from \"./ResetArrayColor\"\r\nconst MAX_VALUE = 55\r\nconst MIN_VALUE = 5\r\nconst ARRAY_LENGTH = MAX_VALUE - MIN_VALUE\r\n\r\n// Create new array of integers\r\nexport function createArray(containerRef, intArr) {\r\n  // resets to original color when new array created\r\n  resetArrayColour(containerRef, intArr)\r\n  // variables for use to create array of\r\n  // numbers from minValue to end of arrayLength\r\n  const tempArr = []\r\n  let arrayValue = MIN_VALUE\r\n  // create array of values from min to max\r\n  for(let i = 0; i < ARRAY_LENGTH; i++) {\r\n    // add array value to temp array\r\n    tempArr.push(arrayValue)\r\n    // add 1 to arrayValue\r\n    arrayValue++\r\n  }\r\n  // shuffle values in array\r\n  shuffleArray(tempArr)\r\n  return tempArr\r\n}\r\n\r\nexport function getArrayLength() {\r\n  return MAX_VALUE - MIN_VALUE\r\n}\r\n\r\nexport function getMinValue(){\r\n  return MIN_VALUE\r\n}\r\n","// Clears colors when array is reset\r\nexport function resetArrayColour(containerRef, intArr) {\r\n    const arrayBars = containerRef.current.children\r\n    // changes bar style back to original color by removing\r\n    // colors after sorting\r\n    for (let i = 0; i < intArr.length; i++) {\r\n      const arrayBarStyle = arrayBars[i].style\r\n      arrayBarStyle.backgroundColor = ''\r\n    }\r\n  }","\r\n// Fisher-Yates algorithm to randomize array items\r\nexport function shuffleArray(array) {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1))\r\n    const temp = array[i]\r\n    array[i] = array[j]\r\n    array[j] = temp\r\n  }\r\n}","export default __webpack_public_path__ + \"static/media/quickSortAlgo.59d510c4.JPG\";","\r\nimport React from 'react'\r\nimport './QuickSortInfo.css'\r\nimport quickSortAlgo from '../../algo-images/quickSortAlgo.JPG'\r\n\r\nexport default function QuickSortInfo() {\r\n  return (\r\n    <div>\r\n      <h2>QuickSort Algorithm</h2>\r\n      \r\n      <div className=\"container\">\r\n\r\n          <div className=\"algo-pic\">\r\n            <img className=\"quicksort-img\" src={quickSortAlgo} alt=\"Quick Sort Algorithm\"></img>     \r\n          </div>\r\n\r\n        <div className=\"algo-info\">\r\n          <h3>Time/Space Complexity</h3>\r\n          <ul>\r\n            <li>Average Time: O(n log(n))</li>  \r\n            <li>Worst Time: O(n^2)</li>\r\n            <li>Space: O(log(n))</li>\r\n          </ul>\r\n\r\n          <h4>Steps for QuickSort</h4>\r\n          <ol>\r\n            <li>Select pivot.  Can select any element(first/last/middle)</li>\r\n            <li>Start left pointer at first element and right pointer at last element.</li>\r\n            <li>Compare left pointer element with pivot element.</li>\r\n            <li>While left pointer element is less than pivot shift left pointer right one element.</li>\r\n            <li>While right pointer element is greater than pivot shift right pointer left one element.</li>\r\n            <li>Check if left pointer element is greater than right pointer element.</li>\r\n            <li>If left element is less than right pointer element swap left and right pointer values.</li>\r\n            <li>Add one to left pointer and subtract one from right pointer</li>\r\n            <li>If the index of the left pointer is less than the index of the right \r\n              pointer repeat the process. If not return the index of the left pointer.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","export default __webpack_public_path__ + \"static/media/mergeSortAlgo.b0ceeec9.JPG\";","import React from 'react'\r\nimport './MergeSort.css'\r\nimport mergeSortAlgo from '../../algo-images/mergeSortAlgo.JPG'\r\n\r\nexport default function MergeSortInfo() {\r\n  return (\r\n    <div>\r\n      <h2>MergeSort Algorithm</h2>\r\n\r\n      <div className=\"container\">\r\n        \r\n          <div className=\"algo-pic\">\r\n            <img className=\"merge-sort-img\" src={mergeSortAlgo} alt=\"Merge Sort Algorithm\"></img>     \r\n          </div>\r\n        <div className=\"algo-info\">\r\n\r\n          <h3>Time/Space Complexity</h3>\r\n          <ul>\r\n            <li>Average Time: O(n log(n))</li>  \r\n            <li>Worst Time: O(n log(n))</li>\r\n            <li>Space: O(n)</li>\r\n          </ul>\r\n      \r\n          <h4>Steps for MergeSort</h4>\r\n          <ol>\r\n            <li>Split given array in half.</li>\r\n            <li>Recursively divide sub-arrays in half until you are left with an array \r\n              with a single value.\r\n            </li>\r\n            <li>Merge single value sub-arrays so that they are sorted.</li>\r\n            <li>Repeat merging sub-arrays and sorting until all values are in sorted array.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","export default __webpack_public_path__ + \"static/media/bubbleSortAlgo.8146cbc2.JPG\";","\r\nimport React from 'react'\r\nimport './BubbleSortInfo.css'\r\nimport bubbleSortAlgo from '../../algo-images/bubbleSortAlgo.JPG'\r\n\r\nexport default function BubbleSortInfo() {\r\n  return (\r\n    <div>\r\n      <h2>BubbleSort Algorithm</h2>\r\n      \r\n      <div className=\"container\">\r\n\r\n          <div className=\"algo-pic\">\r\n            <img className=\"bubble-sort-img\" src={bubbleSortAlgo} alt=\"Bubble Sort Algorithm\"></img>     \r\n          </div>\r\n\r\n        <div className=\"algo-info\">\r\n          <h3>Time/Space Complexity</h3>\r\n          <ul>\r\n            <li>Average Time: O(n^2)</li>  \r\n            <li>Worst Time: O(n^2)</li>\r\n            <li>Space: O(1)</li>\r\n          </ul>\r\n\r\n          <h4>Steps for BubbleSort</h4>\r\n          <ol>\r\n            <li>Start at first item in unsorted array.</li>\r\n            <li>Check if the next item is less than first item.</li>\r\n            <li>If the next item is less than the first swap items.</li>\r\n            <li>Continue checking if next value is greater or less than and switching when\r\n              value is less than.\r\n            </li>\r\n            <li>Continue iterating through all of the items in the array until sorted.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","import React, { useState, useEffect, useRef } from 'react'\r\nimport { getMergeSortAnimations } from '../../algorithms/sorts/MergeSort'\r\nimport { quickSortAnimations } from '../../algorithms/sorts/QuickSort'\r\nimport { bubbleSortAnimations } from '../../algorithms/sorts/BubbleSort'\r\nimport { createArray, getArrayLength, getMinValue } from './create-array-functions/CreateArray'\r\nimport QuickSortInfo from '../../algorithms/info/quick-sort/QuickSortInfo'\r\nimport MergeSortInfo from '../../algorithms/info/merge-sort/MergeSort'\r\nimport BubbleSortInfo from '../../algorithms/info/bubble-sort/BubbleSortInfo'\r\nimport './SortDisplay.css'\r\n\r\nconst DELAY = 15\r\nconst PRIMARY_COLOR = 'green'\r\nconst SECONDARY_COLOR = 'red'\r\n\r\n\r\n\r\nexport default function SortDisplay() {\r\n  const [intArr, setIntArr] = useState([])\r\n  const [info, setInfo] = useState('')\r\n  const containerRef = useRef(null)\r\n  const [disabled, setDisabled] = useState(false)\r\n  const [disableCreate, setDisableCreate] = useState(false)\r\n  \r\n \r\n  // on load creates new array\r\n  useEffect(() => setIntArr(createArray(containerRef, intArr)), [])\r\n\r\n\r\n  // ANIMATION FUNCTIONS\r\n  function animateArrayUpdate(animations) { \r\n    animations.forEach(([comparison, swapped], index) => {\r\n      setTimeout(() => {\r\n        if (!swapped) {\r\n          if (comparison.length === 2) {\r\n            const [i, j] = comparison\r\n            animateArrayAccess(i)\r\n            animateArrayAccess(j)\r\n          } else {\r\n            const [i] = comparison\r\n            animateArrayAccess(i)\r\n          }\r\n        } else {\r\n          setIntArr((prevArr) => {\r\n            const [k, newValue] = comparison\r\n            const newArr = [...prevArr]\r\n            newArr[k] = newValue\r\n            return newArr\r\n          })\r\n        }\r\n      }, index * DELAY)\r\n    })\r\n    setTimeout(() => {\r\n      animateSortedArray()\r\n    }, animations.length * DELAY)\r\n  }\r\n\r\n  function animateArrayAccess(index) {\r\n    \r\n    const arrayBars = containerRef.current.children\r\n    const arrayBarStyle = arrayBars[index].style\r\n    setTimeout(() => {\r\n      arrayBarStyle.backgroundColor = SECONDARY_COLOR\r\n    }, DELAY)\r\n    setTimeout(() => {\r\n      arrayBarStyle.backgroundColor = ''\r\n    }, DELAY * 2)\r\n  }\r\n  // sets color to green when sorted\r\n  function animateSortedArray() {\r\n    \r\n    const arrayBars = containerRef.current.children\r\n    console.log(arrayBars)\r\n    for (let i = 0; i < arrayBars.length -1; i++) {\r\n      const arrayBarStyle = arrayBars[i].style\r\n      setTimeout(\r\n        () => (arrayBarStyle.backgroundColor = PRIMARY_COLOR),\r\n        i * DELAY,\r\n      )\r\n    }\r\n    setTimeout(() => {\r\n     setDisableCreate(false)\r\n    }, arrayBars.length * DELAY)\r\n  }\r\n\r\n  // ON CLICK FUNCTIONS\r\n  function onClickSetIntArr() {\r\n    setInfo('')\r\n    setDisabled(false)\r\n    setIntArr(createArray(containerRef, intArr))\r\n    setDisableCreate(false)\r\n  }\r\n\r\n  \r\n\r\n  // SORTING FUNCTIONS\r\n  // mergeSort\r\n  function mergeSort() {\r\n    setDisabled(true)\r\n    setDisableCreate(true)\r\n    setInfo(MergeSortInfo)\r\n    const animations = getMergeSortAnimations(intArr)\r\n    animateArrayUpdate(animations)\r\n  }\r\n  // quickSort\r\n  function quickSort() {\r\n    setDisabled(true)\r\n    setDisableCreate(true)\r\n    setInfo(QuickSortInfo)\r\n    const animations = quickSortAnimations(intArr)\r\n    animateArrayUpdate(animations)\r\n    \r\n  }\r\n  function bubbleSort() {\r\n    setDisabled(true)\r\n    setDisableCreate(true)\r\n    setInfo(BubbleSortInfo)\r\n    const animations = bubbleSortAnimations(intArr)\r\n    animateArrayUpdate(animations)\r\n    \r\n  }\r\n\r\n\r\n  return (\r\n    <div className=\"display-container\">\r\n      <div className=\"button-container\">\r\n        <button \r\n          className=\"button\" \r\n          id=\"create-array\"\r\n          onClick={() => onClickSetIntArr()}\r\n          disabled={disableCreate}>\r\n            Create/Reset Array\r\n        </button>\r\n        <button\r\n          className=\"button\"\r\n          id=\"merge-sort\"\r\n          onClick={mergeSort}\r\n          disabled={disabled}>\r\n            MergeSort\r\n        </button>\r\n        <button\r\n          className=\"button\"\r\n          id=\"quick-sort\"\r\n          onClick={quickSort}\r\n          disabled={disabled}>\r\n            QuickSort\r\n          </button>  \r\n          <button\r\n          className=\"button\"\r\n          id=\"bubble-sort\"\r\n          onClick={bubbleSort}\r\n          disabled={disabled}>\r\n            BubbleSort\r\n          </button>  \r\n      </div>\r\n      \r\n      <div className=\"array-bar-container\" ref={containerRef}>\r\n        {intArr.map((barHeight, index) => (\r\n          <div\r\n          className=\"array-bar\"\r\n          style={{\r\n            height: `${barHeight}Vmin`,\r\n            width: `${100 / getArrayLength()}vw`,\r\n            color: 'white',\r\n          }}\r\n          key={index}\r\n          >{barHeight - getMinValue() + 1}</div>\r\n        ))}\r\n        <div \r\n        className=\"array-bar-topper\"\r\n        style={{height: `55vmin`,\r\n        width:`${100 / getArrayLength()}vw`}}></div>\r\n      </div>\r\n      <code className=\"info\">{info}</code>\r\n    </div>\r\n  )\r\n}\r\n","import React, {Component} from 'react'\r\n\r\nimport './Node.css'\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props\r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : ''\r\n\r\n    return (\r\n      <td\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></td>\r\n    )\r\n  }\r\n}","// Performs Dijkstra's algorithm returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = []\r\n  startNode.distance = 0\r\n  const unvisitedNodes = getAllNodes(grid)\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes)\r\n    const closestNode = unvisitedNodes.shift()\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder\r\n    closestNode.isVisited = true\r\n    visitedNodesInOrder.push(closestNode)\r\n    if (closestNode === finishNode) return visitedNodesInOrder\r\n    updateUnvisitedNeighbors(closestNode, grid)\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid)\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1\r\n    neighbor.previousNode = node\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = []\r\n  const {col, row} = node\r\n  if (row > 0) neighbors.push(grid[row - 1][col])\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col])\r\n  if (col > 0) neighbors.push(grid[row][col - 1])\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1])\r\n  return neighbors.filter(neighbor => !neighbor.isVisited)\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = []\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node)\r\n    }\r\n  }\r\n  return nodes\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = []\r\n  let currentNode = finishNode\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode)\r\n    currentNode = currentNode.previousNode\r\n  }\r\n  return nodesInShortestPathOrder\r\n}","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function AStar(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid); // Q: different from using grid or slice of grid???\r\n\r\n  while (unvisitedNodes.length) {\r\n    sortByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (!closestNode.isWall) {\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction sortByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}","\r\nimport React from 'react'\r\nimport './DijkstraInfo.css'\r\n//import bubbleSortAlgo from '../../algo-images/bubbleSortAlgo.JPG'\r\n\r\nexport default function DijkstraInfo() {\r\n  return (\r\n    <div>\r\n      <h2>Dijkstra's Algorithm</h2>\r\n      \r\n      <div className=\"container\">\r\n        <div className=\"algo-info\">\r\n          <h3>Time/Space Complexity</h3>\r\n          <p>* Depends on Implementation(V = vertices E = edges)</p>\r\n          <ul>\r\n            <li>Average Time: O(|E| log|V|))</li>  \r\n            <li>Worst Time: O(|V|^2)</li>\r\n            <li>Worst Space: O(|V| + |E|)</li>\r\n          </ul>\r\n          <h4>Steps for Dijkstra's Algorithm</h4>\r\n          <ol>\r\n            <li>Set all vertices distances = infinity except for the \r\n              source vertex, set the source distance = 0.</li>\r\n            <li>Push the source vertex in a min-priority queue in the \r\n              form (distance , vertex), as the comparison in the min-priority \r\n              queue will be according to vertices distances.</li>\r\n            <li>Pop the vertex with the minimum distance from the priority \r\n              queue (at first the popped vertex = source).</li>\r\n            <li>Update the distances of the connected vertices to the popped \r\n              vertex in case of \"current vertex distance + edge weight less \r\n              than next vertex distance\", then push the vertex\r\n              with the new distance to the priority queue.\r\n            </li>\r\n            <li>If the popped vertex is visited before, just continue without using it.</li>\r\n            <li>Apply the same algorithm again until the priority queue is empty.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","\r\nimport React from 'react'\r\nimport './AstarInfo.css'\r\n\r\n\r\nexport default function AstarInfo() {\r\n  return (\r\n    <div>\r\n      <h2>A * Algorithm</h2>\r\n      \r\n      <div className=\"container\">\r\n        <div className=\"algo-info\">\r\n          <h3>Time/Space Complexity</h3>\r\n          <p>* Depends on Implementation</p>\r\n\r\n          <h4>Steps for A * Algorithm</h4>\r\n          <ol>\r\n            <li>Set all vertices distances = infinity except for the \r\n              source vertex, set the source distance = 0.</li>\r\n            <li>Push the source vertex in a min-priority queue in the \r\n              form (distance , vertex), as the comparison in the min-priority \r\n              queue will be according to vertices distances.</li>\r\n            <li>Pop the vertex with the minimum distance from the priority \r\n              queue (at first the popped vertex = source).</li>\r\n            <li>Update the distances of the connected vertices to the popped \r\n              vertex in case of \"current vertex distance + edge weight less \r\n              than next vertex distance\", then push the vertex\r\n              with the new distance to the priority queue.\r\n            </li>\r\n            <li>If the popped vertex is visited before, just continue without using it.</li>\r\n            <li>Apply the same algorithm again until the priority queue is empty.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","\r\nimport React from 'react'\r\nimport './BreathFirstSearhInfo.css'\r\n\r\n\r\nexport default function DijkstraInfo() {\r\n  return (\r\n    <div>\r\n      <h2>Breath First Search Algorithm</h2>\r\n      \r\n      <div className=\"container\">\r\n        <div className=\"algo-info\">\r\n          <h3>Time/Space Complexity</h3>\r\n          <p>* Depends on Implementation</p>\r\n\r\n          <h4>Steps for Dijkstra's Algorithm</h4>\r\n          <ol>\r\n            <li>Set all vertices distances = infinity except for the \r\n              source vertex, set the source distance = 0.</li>\r\n            <li>Push the source vertex in a min-priority queue in the \r\n              form (distance , vertex), as the comparison in the min-priority \r\n              queue will be according to vertices distances.</li>\r\n            <li>Pop the vertex with the minimum distance from the priority \r\n              queue (at first the popped vertex = source).</li>\r\n            <li>Update the distances of the connected vertices to the popped \r\n              vertex in case of \"current vertex distance + edge weight less \r\n              than next vertex distance\", then push the vertex\r\n              with the new distance to the priority queue.\r\n            </li>\r\n            <li>If the popped vertex is visited before, just continue without using it.</li>\r\n            <li>Apply the same algorithm again until the priority queue is empty.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","\r\nimport React from 'react'\r\nimport './DepthFirstSearchInfo.css'\r\n\r\n\r\nexport default function DepthFirstSearchInfo() {\r\n  return (\r\n    <div>\r\n      <h2>Depth First Search Algorithm</h2>\r\n      \r\n      <div className=\"container\">\r\n        <div className=\"algo-info\">\r\n          <h3>Time/Space Complexity</h3>\r\n          <p>* Depends on Implementation</p>\r\n\r\n          <h4>Steps for Dijkstra's Algorithm</h4>\r\n          <ol>\r\n            <li>Set all vertices distances = infinity except for the \r\n              source vertex, set the source distance = 0.</li>\r\n            <li>Push the source vertex in a min-priority queue in the \r\n              form (distance , vertex), as the comparison in the min-priority \r\n              queue will be according to vertices distances.</li>\r\n            <li>Pop the vertex with the minimum distance from the priority \r\n              queue (at first the popped vertex = source).</li>\r\n            <li>Update the distances of the connected vertices to the popped \r\n              vertex in case of \"current vertex distance + edge weight less \r\n              than next vertex distance\", then push the vertex\r\n              with the new distance to the priority queue.\r\n            </li>\r\n            <li>If the popped vertex is visited before, just continue without using it.</li>\r\n            <li>Apply the same algorithm again until the priority queue is empty.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","import React, { Component } from 'react'\r\nimport Node from '../node/Node'\r\nimport { dijkstra } from '../../../algorithms/searches/Dijkstra'\r\nimport { AStar } from '../../../algorithms/searches/AStar'\r\nimport { dfs } from '../../../algorithms/searches/DepthFirstSearch'\r\nimport { bfs } from '../../../algorithms/searches/BreathFirstSearch'\r\nimport DijkstraInfo from '../../../algorithms/info/dijkstra/DijkstraInfo'\r\nimport AstarInfo from '../../../algorithms/info/a-star/AstarInfo'\r\nimport BreathFirstSearchInfo from '../../../algorithms/info/breath-first-search/BreathFirstSearchInfo'\r\nimport DepthFirstSearchInfo from '../../../algorithms/info/depth-first-search/DepthFirstSearchInfo'\r\n\r\n\r\nimport './Graph.css'\r\n\r\nexport default class Graph extends Component {\r\n  constructor() {\r\n    super()\r\n    this.state = {\r\n      grid: [],\r\n      START_NODE_ROW: 1,\r\n      FINISH_NODE_ROW: 12,\r\n      START_NODE_COL: 2,\r\n      FINISH_NODE_COL: 12,\r\n      mouseIsPressed: false,\r\n      ROW_COUNT: 15,\r\n      COLUMN_COUNT: 15,\r\n      isRunning: false,\r\n      isStartNode: false,\r\n      isFinishNode: false,\r\n      isWallNode: false, \r\n      currRow: 0,\r\n      currCol: 0,\r\n      info: '',\r\n    }\r\n\r\n    this.handleMouseDown = this.handleMouseDown.bind(this)\r\n    this.handleMouseLeave = this.handleMouseLeave.bind(this)\r\n    this.toggleIsRunning = this.toggleIsRunning.bind(this)\r\n  }\r\n  // occurs when page loads\r\n  // create initial grid and set state\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid()\r\n    this.setState({grid})\r\n  }\r\n\r\n  toggleIsRunning() {\r\n    this.setState({isRunning: !this.state.isRunning})\r\n  }\r\n\r\n\r\n  // Create initial grid with number of rows and columns\r\n  getInitialGrid = (\r\n    rowCount = this.state.ROW_COUNT,\r\n    colCount = this.state.COLUMN_COUNT,\r\n  ) => {\r\n    const initialGrid = []\r\n    for (let row = 0; row < rowCount; row++) {\r\n      const currentRow = []\r\n      for (let col = 0; col < colCount; col++) {\r\n        currentRow.push(this.createNode(row, col))\r\n      }\r\n      initialGrid.push(currentRow)\r\n    }\r\n    return initialGrid\r\n  }\r\n\r\n  // Creates node with row and column values\r\n  createNode = (row, col) => {\r\n    return {\r\n      row,\r\n      col,\r\n      isStart:\r\n        row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n      isFinish:\r\n        row === this.state.FINISH_NODE_ROW &&\r\n        col === this.state.FINISH_NODE_COL,\r\n      distance: Infinity,\r\n      distanceToFinishNode:\r\n        Math.abs(this.state.FINISH_NODE_ROW - row) +\r\n        Math.abs(this.state.FINISH_NODE_COL - col),\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      isNode: true,\r\n    }\r\n  }\r\n\r\n // What happens when you click down on mouse\r\n  handleMouseDown(row, col) {\r\n    // check to make sure animation is not running\r\n    if (!this.state.isRunning) {\r\n      // check to see if grid is clear\r\n      if (this.isGridClear()) {\r\n        // determines if start node\r\n        if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-start'\r\n        ) {\r\n          // selects if click on start node allowing change of start\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isStartNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          })\r\n          // determines of finish node\r\n        } else if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-finish'\r\n        ) {\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isFinishNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          })\r\n        } else {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col)\r\n          this.setState({\r\n            grid: newGrid,\r\n            mouseIsPressed: true,\r\n            isWallNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          })\r\n        }\r\n      } else {\r\n        // resets grid if path search has run and click down on mouse\r\n        this.clearGrid()\r\n      }\r\n    }\r\n  }\r\n\r\n  isGridClear() {\r\n    // traverse rows of grid\r\n    for (const row of this.state.grid) {\r\n      // traverse columns of grid\r\n      for (const node of row) {\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className\r\n        if (\r\n          nodeClassName === 'node node-visited' ||\r\n          nodeClassName === 'node node-shortest-path'\r\n        ) {\r\n          return false\r\n        }\r\n      }\r\n    }\r\n    return true\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.isRunning) {\r\n      if (this.state.mouseIsPressed) {\r\n        const nodeClassName = document.getElementById(`node-${row}-${col}`)\r\n          .className\r\n        if (this.state.isStartNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevStartNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ]\r\n            prevStartNode.isStart = false\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node'\r\n\r\n            this.setState({currRow: row, currCol: col})\r\n            const currStartNode = this.state.grid[row][col]\r\n            currStartNode.isStart = true\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-start'\r\n          }\r\n          this.setState({START_NODE_ROW: row, START_NODE_COL: col})\r\n        } else if (this.state.isFinishNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevFinishNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ]\r\n            prevFinishNode.isFinish = false\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node'\r\n\r\n            this.setState({currRow: row, currCol: col})\r\n            const currFinishNode = this.state.grid[row][col]\r\n            currFinishNode.isFinish = true\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-finish'\r\n          }\r\n          this.setState({FINISH_NODE_ROW: row, FINISH_NODE_COL: col})\r\n        } else if (this.state.isWallNode) {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col)\r\n          this.setState({grid: newGrid})\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseUp(row, col) {\r\n    if (!this.state.isRunning) {\r\n      this.setState({mouseIsPressed: false})\r\n      if (this.state.isStartNode) {\r\n        const isStartNode = !this.state.isStartNode\r\n        this.setState({isStartNode, START_NODE_ROW: row, START_NODE_COL: col})\r\n      } else if (this.state.isFinishNode) {\r\n        const isFinishNode = !this.state.isFinishNode\r\n        this.setState({\r\n          isFinishNode,\r\n          FINISH_NODE_ROW: row,\r\n          FINISH_NODE_COL: col,\r\n        })\r\n      }\r\n      this.getInitialGrid()\r\n    }\r\n  }\r\n\r\n  handleMouseLeave() {\r\n    if (this.state.isStartNode) {\r\n      const isStartNode = !this.state.isStartNode\r\n      this.setState({isStartNode, mouseIsPressed: false})\r\n    } else if (this.state.isFinishNode) {\r\n      const isFinishNode = !this.state.isFinishNode\r\n      this.setState({isFinishNode, mouseIsPressed: false})\r\n    } else if (this.state.isWallNode) {\r\n      const isWallNode = !this.state.isWallNode\r\n      this.setState({isWallNode, mouseIsPressed: false})\r\n      this.getInitialGrid()\r\n    }\r\n  }\r\n\r\n  /******************** Clear Board/Walls ********************/\r\n\r\n  clearGrid() {\r\n    if (!this.state.isRunning) {\r\n      this.setState({info: ''})\r\n      const newGrid = this.state.grid.slice()\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish' &&\r\n            nodeClassName !== 'node node-wall'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node'\r\n            node.isVisited = false\r\n            node.distance = Infinity\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col)\r\n          }\r\n          if (nodeClassName === 'node node-finish') {\r\n            node.isVisited = false\r\n            node.distance = Infinity\r\n            node.distanceToFinishNode = 0\r\n          }\r\n          if (nodeClassName === 'node node-start') {\r\n            node.isVisited = false\r\n            node.distance = Infinity\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col)\r\n            node.isStart = true\r\n            node.isWall = false\r\n            node.previousNode = null\r\n            node.isNode = true\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  clearWalls() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice()\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className\r\n          if (nodeClassName === 'node node-wall') {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node'\r\n            node.isWall = false\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /******************** Create Animations ********************/\r\n  visualize(algo) {\r\n    if (!this.state.isRunning) {\r\n      \r\n      this.clearGrid()\r\n      this.toggleIsRunning()\r\n      const {grid} = this.state\r\n      const startNode =\r\n        grid[this.state.START_NODE_ROW][this.state.START_NODE_COL]\r\n      const finishNode =\r\n        grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL]\r\n      let visitedNodesInOrder\r\n      switch (algo) {\r\n        case 'Dijkstra':\r\n          this.setState({info: <DijkstraInfo></DijkstraInfo>})\r\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode)\r\n          break\r\n        case 'AStar':\r\n          this.setState({info: <AstarInfo></AstarInfo>})\r\n          visitedNodesInOrder = AStar(grid, startNode, finishNode)\r\n          break\r\n        case 'BFS':\r\n          this.setState({info: <BreathFirstSearchInfo></BreathFirstSearchInfo>})\r\n          visitedNodesInOrder = bfs(grid, startNode, finishNode)\r\n          break\r\n        case 'DFS':\r\n          this.setState({info: <DepthFirstSearchInfo></DepthFirstSearchInfo>})\r\n          visitedNodesInOrder = dfs(grid, startNode, finishNode)\r\n          break\r\n        default:\r\n          // should never get here\r\n          break\r\n      }\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode)\r\n      nodesInShortestPathOrder.push('end')\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder)\r\n    }\r\n  }\r\n\r\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder)\r\n        }, 10 * i)\r\n        return\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i]\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className\r\n        if (\r\n          nodeClassName !== 'node node-start' &&\r\n          nodeClassName !== 'node node-finish'\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node node-visited'\r\n        }\r\n      }, 10 * i)\r\n    }\r\n  }\r\n\r\n  /******************** Create path from start to finish ********************/\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      if (nodesInShortestPathOrder[i] === 'end') {\r\n        setTimeout(() => {\r\n          this.toggleIsRunning()\r\n        }, i * 50)\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i]\r\n          const nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node node-shortest-path'\r\n          }\r\n        }, i * 40)\r\n      }\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const {grid, mouseIsPressed} = this.state\r\n    return (\r\n\r\n      <div className=\"main-container\">\r\n        <div className=\"left-side\">\r\n         \r\n          <div className=\"info-box\">{this.state.info}</div>\r\n        </div>\r\n        <div className=\"button-container-graph\">\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-danger\"\r\n            onClick={() => this.clearGrid()}>\r\n            Clear Grid\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-warning\"\r\n            onClick={() => this.clearWalls()}>\r\n            Clear Walls\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => this.visualize('Dijkstra')}>\r\n            Dijkstra's\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => this.visualize('AStar')}>\r\n            A*\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => this.visualize('BFS')}>\r\n            Breath First Search\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => this.visualize('DFS')}>\r\n            Depth First Search\r\n          </button>\r\n        \r\n\r\n        <table\r\n          className=\"grid-container\"\r\n          onMouseLeave={() => this.handleMouseLeave()}>\r\n          <tbody className=\"grid\">\r\n            {grid.map((row, rowIdx) => {\r\n              return (\r\n                <tr key={rowIdx}>\r\n                  {row.map((node, nodeIdx) => {\r\n                    const {row, col, isFinish, isStart, isWall} = node\r\n                    return (\r\n                      <Node\r\n                        key={nodeIdx}\r\n                        col={col}\r\n                        isFinish={isFinish}\r\n                        isStart={isStart}\r\n                        isWall={isWall}\r\n                        mouseIsPressed={mouseIsPressed}\r\n                        onMouseDown={(row, col) =>\r\n                          this.handleMouseDown(row, col)\r\n                        }\r\n                        onMouseEnter={(row, col) =>\r\n                          this.handleMouseEnter(row, col)\r\n                        }\r\n                        onMouseUp={() => this.handleMouseUp(row, col)}\r\n                        row={row}></Node>\r\n                    )\r\n                  })}\r\n                </tr>\r\n              )\r\n            })}\r\n          </tbody>\r\n        </table>\r\n          <div className=\"instructions-container\">\r\n            <h4>Instructions</h4>\r\n            <ul className=\"instructions-list\">\r\n              <li>You  can move the start an end nodes by clicking and dragging the nodes within\r\n                the grid.\r\n              </li>\r\n              <li>You can create walls by clicking empty squares on the grid.  They will turn \r\n                black.</li>\r\n            </ul>\r\n          </div> \r\n        </div>     \r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n/******************** Create Walls ********************/\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\r\n  const newGrid = grid.slice()\r\n  const node = newGrid[row][col]\r\n  if (!node.isStart && !node.isFinish && node.isNode) {\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    }\r\n    newGrid[row][col] = newNode\r\n  }\r\n  return newGrid\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called after the path-finding methods.\r\nfunction getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = []\r\n  let currentNode = finishNode\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode)\r\n    currentNode = currentNode.previousNode\r\n  }\r\n  return nodesInShortestPathOrder\r\n}","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  let nextNodesStack = [startNode];\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.shift();\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // return visitedNodesInOrder;\r\n}","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const nextNodesStack = [];\r\n  nextNodesStack.push(startNode);\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.pop();\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","import React, {Fragment} from 'react';\r\nimport { Routes, Route } from 'react-router-dom'\r\nimport './App.css';\r\nimport Header from './components/header/Header'\r\nimport SortDisplay from './components/sort-display/SortDisplay';\r\nimport Graph from './components/path-finder/graph/Graph'\r\n\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Fragment>\r\n        <Header/>\r\n        <main>\r\n        <Routes>\r\n          <Route\r\n            path='algorithm-demo/sort'\r\n            element={<SortDisplay/>}/>\r\n        \r\n          <Route\r\n            path='algorithm-demo/path'\r\n            element={<Graph/>}/>\r\n          </Routes>\r\n        </main>\r\n      </Fragment>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport { BrowserRouter } from 'react-router-dom'\r\n\r\n\r\nReactDOM.render(\r\n  <BrowserRouter>\r\n    <App/>\r\n  </BrowserRouter>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}