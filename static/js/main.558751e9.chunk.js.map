{"version":3,"sources":["components/header/Header.js","algorithms/sorts/MergeSort.js","algorithms/sorts/QuickSort.js","algorithms/sorts/BubbleSort.js","components/sort-display/create-array-functions/CreateArray.js","components/sort-display/create-array-functions/ResetArrayColor.js","components/sort-display/create-array-functions/ShuffleArray.js","algorithms/algo-images/quickSortAlgo.JPG","algorithms/info/quick-sort/QuickSortInfo.js","algorithms/algo-images/mergeSortAlgo.JPG","algorithms/info/merge-sort/MergeSort.js","algorithms/algo-images/bubbleSortAlgo.JPG","algorithms/info/bubble-sort/BubbleSortInfo.js","components/sort-display/SortDisplay.js","components/path-finder/node/Node.js","algorithms/searches/Dijkstra.js","algorithms/searches/AStar.js","components/path-finder/graph/Graph.js","algorithms/searches/BreathFirstSearch.js","algorithms/searches/DepthFirstSearch.js","App.js","index.js"],"names":["Header","className","Navbar","Brand","Nav","to","getMergeSortAnimations","arr","copyArray","len","length","animations","mergeSortHelper","Array","tempArray","left","right","mid","Math","floor","i","j","k","push","merge","quickSortAnimations","quickSort","start","end","part","pivot","swap","partition","index1","index2","temp","bubbleSortAnimations","isSwapped","bubbleSort","createArray","containerRef","intArr","arrayBars","current","children","style","backgroundColor","resetArrayColour","tempArr","arrayValue","MAX_VALUE","array","random","shuffleArray","QuickSortInfo","src","quickSortAlgo","alt","MergeSortInfo","mergeSortAlgo","BubbleSortInfo","bubbleSortAlgo","PRIMARY_COLOR","SortDisplay","useState","setIntArr","info","setInfo","useRef","disabled","setDisabled","disableCreate","setDisableCreate","animateArrayUpdate","forEach","index","comparison","swapped","setTimeout","prevArr","newValue","newArr","animateArrayAccess","console","log","arrayBarStyle","animateSortedArray","DELAY","useEffect","id","onClick","ref","map","barHeight","height","width","color","Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","AStar","sortByDistance","distanceToFinishNode","Graph","getInitialGrid","rowCount","state","ROW_COUNT","colCount","COLUMN_COUNT","initialGrid","currentRow","createNode","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","abs","isNode","mouseIsPressed","isRunning","isStartNode","isFinishNode","isWallNode","currRow","currCol","isDesktopView","handleMouseDown","bind","handleMouseLeave","toggleIsRunning","setState","isGridClear","document","getElementById","newGrid","getNewGridWithWallToggled","clearGrid","nodeClassName","slice","algo","nextNodesStack","currentNode","nextNode","bfs","pop","dfs","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","animate","animateShortestPath","type","clearWalls","visualize","onMouseLeave","rowIdx","nodeIdx","handleMouseEnter","handleMouseUp","newNode","App","path","element","ReactDOM","render"],"mappings":"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","file":"static/js/main.558751e9.chunk.js","sourcesContent":["import React from 'react'\r\nimport Nav from 'react-bootstrap/Nav'\r\nimport Navbar from 'react-bootstrap/Navbar'\r\nimport { NavLink } from 'react-router-dom'\r\nimport './Header.css'\r\n\r\n\r\nconst Header = () => (\r\n  <div className=\"header\">\r\n    <Navbar>\r\n      <Navbar.Brand>Algorithm Demo</Navbar.Brand>\r\n        <Nav>\r\n          <NavLink className=\"nav-link\" to=\"/\">Home</NavLink>\r\n          <NavLink className=\"nav-link\" to=\"/sort\">Sorter</NavLink>\r\n          <NavLink className=\"nav-link\" to=\"/path\">Pathfinder</NavLink>\r\n        </Nav>\r\n    </Navbar>\r\n  </div>\r\n)\r\n\r\nexport default Header\r\n","export function getMergeSortAnimations(arr) {\r\n  const copyArray = [...arr]\r\n  const len = copyArray.length\r\n  const tempArray = Array(len)\r\n  const animations = []\r\n  mergeSortHelper(copyArray, tempArray, 0, len - 1, animations)\r\n  return animations\r\n}\r\n\r\nfunction mergeSortHelper(arr, tempArray, left, right, animations) {\r\n  if (right <= left) return\r\n  const mid = left + Math.floor((right - left) / 2)\r\n  mergeSortHelper(arr, tempArray, left, mid, animations)\r\n  mergeSortHelper(arr, tempArray, mid + 1, right, animations)\r\n  merge(arr, tempArray, left, mid, right, animations)\r\n}\r\n\r\nfunction merge(arr, tempArray, left, mid, right, animations) {\r\n  for (let i = left; i <= right; i++) tempArray[i] = arr[i]\r\n  let i = left\r\n  let j = mid + 1\r\n  for (let k = left; k <= right; k++) {\r\n    if (i > mid) {\r\n      animations.push([[j], false])\r\n      animations.push([[k, tempArray[j]], true])\r\n      arr[k] = tempArray[j++]\r\n    } else if (j > right) {\r\n      animations.push([[i], false])\r\n      animations.push([[k, tempArray[i]], true])\r\n      arr[k] = tempArray[i++]\r\n    } else if (tempArray[j] < tempArray[i]) {\r\n      animations.push([[i, j], false])\r\n      animations.push([[k, tempArray[j]], true])\r\n      arr[k] = tempArray[j++]\r\n    } else {\r\n      animations.push([[i, j], false])\r\n      animations.push([[k, tempArray[i]], true])\r\n      arr[k] = tempArray[i++]\r\n    }\r\n  }\r\n}","export function quickSortAnimations(arr) {\r\n    // copy the array\r\n    const copyArray = [...arr]\r\n    // create array for animations\r\n    const animations = []\r\n    // run quicksort\r\n    quickSort(copyArray, 0, copyArray.length - 1, animations)\r\n    // return animation array for 'main' \r\n    return animations\r\n  }\r\n  \r\n  function quickSort(arr, start, end, animations) {\r\n    // check that end is > start\r\n    if (end <= start) return\r\n    // get partition value for recursive calls\r\n    const part = partition(arr, start, end, animations)\r\n    // recursive calls to go through all of array\r\n    quickSort(arr, start, part, animations)\r\n    quickSort(arr, part + 1, end, animations)\r\n  }\r\n  \r\n  function partition(arr, start, end, animations) {\r\n    // start pointer\r\n    let i = start\r\n    // end pointer\r\n    let j = end + 1\r\n    // set pivot to first element in arr\r\n    const pivot = arr[start]\r\n    \r\n    // run until break\r\n    while (true) {\r\n      // move right one from start and checks value against pivot\r\n      while (arr[++i] <= pivot) {\r\n        // quit if i gets to end of array\r\n        if (i === end) break\r\n        // add array of [i, false] to animations array\r\n        animations.push([[i], false])\r\n      }\r\n      // moves left one from end and checks pivot\r\n      while (arr[--j] >= pivot) {\r\n        // quit if j gets to start of array\r\n        if (j === start) break\r\n        // add array of [j, false] to animations array\r\n        animations.push([[j], false])\r\n      }\r\n      // quit if end index is < = to start index\r\n      if (j <= i) break\r\n      // add array [[i, arrayValue at j], true]\r\n      animations.push([[i, arr[j]], true])\r\n      // add array [[j, arrayValue at i], true]\r\n      animations.push([[j, arr[i]], true])\r\n      // switch i with j in arr\r\n      swap(arr, i, j)\r\n    }\r\n\r\n    // add array to animation [[start index, arrayValue at j],\r\n    // true]\r\n    animations.push([[start, arr[j]], true])\r\n    // add array to animation [[j index, arrayValue at start index],\r\n    // true]\r\n    animations.push([[j, arr[start]], true])\r\n    // swap start element with jth element\r\n    swap(arr, start, j)\r\n    // return index at j\r\n    return j\r\n  }\r\n\r\n  function swap(arr, index1, index2) {\r\n    // create temp value and set to index1 value\r\n    const temp = arr[index1]\r\n    // change index1 value to index2 value\r\n    arr[index1] = arr[index2]\r\n    // set index2 value to temp value that was index1 old value\r\n    arr[index2] = temp\r\n  }","export function bubbleSortAnimations(arr) {\r\n  // copy the array\r\n  const copyArray = [...arr]\r\n  const animations = []\r\n\r\n  bubbleSort(copyArray, animations)\r\n\r\n  return animations\r\n}\r\n\r\nfunction bubbleSort(arr, animations) {\r\n  let i, j\r\n  let len = arr.length\r\n  let isSwapped = false\r\n\r\n  for (i = 0; i < len; i++){\r\n    isSwapped = false\r\n    for (j = 0; j < len; j ++){\r\n      \r\n      if(arr[j] > arr[j + 1]) {\r\n        animations.push([[j, arr[j + 1]], true])\r\n        animations.push([[j + 1, arr[j]], true])\r\n        swap(arr, j, j + 1)\r\n        isSwapped = true\r\n        \r\n      } \r\n        animations.push([[j], false])\r\n    }\r\n    if(!isSwapped){\r\n      break\r\n    }\r\n  }\r\n  return j\r\n}\r\nfunction swap(arr, index1, index2) {\r\n  // create temp value and set to index1 value\r\n  const temp = arr[index1]\r\n  // change index1 value to index2 value\r\n  arr[index1] = arr[index2]\r\n  // set index2 value to temp value that was index1 old value\r\n  arr[index2] = temp\r\n}\r\n","import { shuffleArray } from \"./ShuffleArray\"\r\nimport { resetArrayColour } from \"./ResetArrayColor\"\r\nconst MAX_VALUE = 55\r\nconst MIN_VALUE = 5\r\nconst ARRAY_LENGTH = MAX_VALUE - MIN_VALUE\r\n\r\n// Create new array of integers\r\nexport function createArray(containerRef, intArr) {\r\n  // resets to original color when new array created\r\n  resetArrayColour(containerRef, intArr)\r\n  // variables for use to create array of\r\n  // numbers from minValue to end of arrayLength\r\n  const tempArr = []\r\n  let arrayValue = MIN_VALUE\r\n  // create array of values from min to max\r\n  for(let i = 0; i < ARRAY_LENGTH; i++) {\r\n    // add array value to temp array\r\n    tempArr.push(arrayValue)\r\n    // add 1 to arrayValue\r\n    arrayValue++\r\n  }\r\n  // shuffle values in array\r\n  shuffleArray(tempArr)\r\n  return tempArr\r\n}\r\n\r\nexport function getArrayLength() {\r\n  return MAX_VALUE - MIN_VALUE\r\n}\r\n\r\nexport function getMinValue(){\r\n  return MIN_VALUE\r\n}\r\n","// Clears colors when array is reset\r\nexport function resetArrayColour(containerRef, intArr) {\r\n    const arrayBars = containerRef.current.children\r\n    // changes bar style back to original color by removing\r\n    // colors after sorting\r\n    for (let i = 0; i < intArr.length; i++) {\r\n      const arrayBarStyle = arrayBars[i].style\r\n      arrayBarStyle.backgroundColor = ''\r\n    }\r\n  }","\r\n// Fisher-Yates algorithm to randomize array items\r\nexport function shuffleArray(array) {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1))\r\n    const temp = array[i]\r\n    array[i] = array[j]\r\n    array[j] = temp\r\n  }\r\n}","export default __webpack_public_path__ + \"static/media/quickSortAlgo.59d510c4.JPG\";","\r\nimport React from 'react'\r\nimport './QuickSortInfo.css'\r\nimport quickSortAlgo from '../../algo-images/quickSortAlgo.JPG'\r\n\r\nexport default function QuickSortInfo() {\r\n  return (\r\n    <div>\r\n      <h2>QuickSort Algorithm</h2>\r\n      \r\n      <div className=\"container\">\r\n\r\n          <div className=\"algo-pic\">\r\n            <img className=\"quicksort-img\" src={quickSortAlgo} alt=\"Quick Sort Algorithm\"></img>     \r\n          </div>\r\n\r\n        <div className=\"algo-info\">\r\n          <h3>Time/Space Complexity</h3>\r\n          <ul>\r\n            <li>Average Time: O(n log(n))</li>  \r\n            <li>Worst Time: O(n^2)</li>\r\n            <li>Space: O(log(n))</li>\r\n          </ul>\r\n\r\n          <h4>Steps for QuickSort</h4>\r\n          <ol>\r\n            <li>Select pivot.  Can select any element(first/last/middle)</li>\r\n            <li>Start left pointer at first element and right pointer at last element.</li>\r\n            <li>Compare left pointer element with pivot element.</li>\r\n            <li>While left pointer element is less than pivot shift left pointer right one element.</li>\r\n            <li>While right pointer element is greater than pivot shift right pointer left one element.</li>\r\n            <li>Check if left pointer element is greater than right pointer element.</li>\r\n            <li>If left element is less than right pointer element swap left and right pointer values.</li>\r\n            <li>Add one to left pointer and subtract one from right pointer</li>\r\n            <li>If the index of the left pointer is less than the index of the right \r\n              pointer repeat the process. If not return the index of the left pointer.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","export default __webpack_public_path__ + \"static/media/mergeSortAlgo.b0ceeec9.JPG\";","import React from 'react'\r\nimport './MergeSort.css'\r\nimport mergeSortAlgo from '../../algo-images/mergeSortAlgo.JPG'\r\n\r\nexport default function MergeSortInfo() {\r\n  return (\r\n    <div>\r\n      <h2>MergeSort Algorithm</h2>\r\n\r\n      <div className=\"container\">\r\n        \r\n          <div className=\"algo-pic\">\r\n            <img className=\"merge-sort-img\" src={mergeSortAlgo} alt=\"Merge Sort Algorithm\"></img>     \r\n          </div>\r\n        <div className=\"algo-info\">\r\n\r\n          <h3>Time/Space Complexity</h3>\r\n          <ul>\r\n            <li>Average Time: O(n log(n))</li>  \r\n            <li>Worst Time: O(n log(n))</li>\r\n            <li>Space: O(n)</li>\r\n          </ul>\r\n      \r\n          <h4>Steps for MergeSort</h4>\r\n          <ol>\r\n            <li>Split given array in half.</li>\r\n            <li>Recursively divide sub-arrays in half until you are left with an array \r\n              with a single value.\r\n            </li>\r\n            <li>Merge single value sub-arrays so that they are sorted.</li>\r\n            <li>Repeat merging sub-arrays and sorting until all values are in sorted array.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","export default __webpack_public_path__ + \"static/media/bubbleSortAlgo.8146cbc2.JPG\";","\r\nimport React from 'react'\r\nimport './BubbleSortInfo.css'\r\nimport bubbleSortAlgo from '../../algo-images/bubbleSortAlgo.JPG'\r\n\r\nexport default function BubbleSortInfo() {\r\n  return (\r\n    <div>\r\n      <h2>BubbleSort Algorithm</h2>\r\n      \r\n      <div className=\"container\">\r\n\r\n          <div className=\"algo-pic\">\r\n            <img className=\"bubble-sort-img\" src={bubbleSortAlgo} alt=\"Bubble Sort Algorithm\"></img>     \r\n          </div>\r\n\r\n        <div className=\"algo-info\">\r\n          <h3>Time/Space Complexity</h3>\r\n          <ul>\r\n            <li>Average Time: O(n^2)</li>  \r\n            <li>Worst Time: O(n^2)</li>\r\n            <li>Space: O(1)</li>\r\n          </ul>\r\n\r\n          <h4>Steps for BubbleSort</h4>\r\n          <ol>\r\n            <li>Start at first item in unsorted array.</li>\r\n            <li>Check if the next item is less than first item.</li>\r\n            <li>If the next item is less than the first swap items.</li>\r\n            <li>Continue checking if next value is greater or less than and switching when\r\n              value is less than.\r\n            </li>\r\n            <li>Continue iterating through all of the items in the array until sorted.</li>\r\n          </ol>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","import React, { useState, useEffect, useRef } from 'react'\r\nimport { getMergeSortAnimations } from '../../algorithms/sorts/MergeSort'\r\nimport { quickSortAnimations } from '../../algorithms/sorts/QuickSort'\r\nimport { bubbleSortAnimations } from '../../algorithms/sorts/BubbleSort'\r\nimport { createArray, getArrayLength, getMinValue } from './create-array-functions/CreateArray'\r\nimport QuickSortInfo from '../../algorithms/info/quick-sort/QuickSortInfo'\r\nimport MergeSortInfo from '../../algorithms/info/merge-sort/MergeSort'\r\nimport BubbleSortInfo from '../../algorithms/info/bubble-sort/BubbleSortInfo'\r\nimport './SortDisplay.css'\r\n\r\nconst DELAY = 5\r\nconst PRIMARY_COLOR = 'green'\r\nconst SECONDARY_COLOR = 'red'\r\n\r\n\r\n\r\nexport default function SortDisplay() {\r\n  const [intArr, setIntArr] = useState([])\r\n  const [info, setInfo] = useState('')\r\n  const containerRef = useRef(null)\r\n  const [disabled, setDisabled] = useState(false)\r\n  const [disableCreate, setDisableCreate] = useState(false)\r\n  \r\n \r\n  // on load creates new array\r\n  useEffect(() => setIntArr(createArray(containerRef, intArr)), [])\r\n\r\n\r\n  // ANIMATION FUNCTIONS\r\n  function animateArrayUpdate(animations) { \r\n    animations.forEach(([comparison, swapped], index) => {\r\n      setTimeout(() => {\r\n        if (!swapped) {\r\n          if (comparison.length === 2) {\r\n            const [i, j] = comparison\r\n            animateArrayAccess(i)\r\n            animateArrayAccess(j)\r\n          } else {\r\n            const [i] = comparison\r\n            animateArrayAccess(i)\r\n          }\r\n        } else {\r\n          setIntArr((prevArr) => {\r\n            const [k, newValue] = comparison\r\n            const newArr = [...prevArr]\r\n            newArr[k] = newValue\r\n            return newArr\r\n          })\r\n        }\r\n      }, index * DELAY)\r\n    })\r\n    setTimeout(() => {\r\n      animateSortedArray()\r\n    }, animations.length * DELAY)\r\n  }\r\n\r\n  function animateArrayAccess(index) {\r\n    \r\n    const arrayBars = containerRef.current.children\r\n    const arrayBarStyle = arrayBars[index].style\r\n    setTimeout(() => {\r\n      arrayBarStyle.backgroundColor = SECONDARY_COLOR\r\n    }, DELAY)\r\n    setTimeout(() => {\r\n      arrayBarStyle.backgroundColor = ''\r\n    }, DELAY * 2)\r\n  }\r\n  // sets color to green when sorted\r\n  function animateSortedArray() {\r\n    \r\n    const arrayBars = containerRef.current.children\r\n    console.log(arrayBars)\r\n    for (let i = 0; i < arrayBars.length -1; i++) {\r\n      const arrayBarStyle = arrayBars[i].style\r\n      setTimeout(\r\n        () => (arrayBarStyle.backgroundColor = PRIMARY_COLOR),\r\n        i * DELAY,\r\n      )\r\n    }\r\n    setTimeout(() => {\r\n     setDisableCreate(false)\r\n    }, arrayBars.length * DELAY)\r\n  }\r\n\r\n  // ON CLICK FUNCTIONS\r\n  function onClickSetIntArr() {\r\n    setInfo('')\r\n    setDisabled(false)\r\n    setIntArr(createArray(containerRef, intArr))\r\n    setDisableCreate(false)\r\n  }\r\n\r\n  \r\n\r\n  // SORTING FUNCTIONS\r\n  // mergeSort\r\n  function mergeSort() {\r\n    setDisabled(true)\r\n    setDisableCreate(true)\r\n    setInfo(MergeSortInfo)\r\n    const animations = getMergeSortAnimations(intArr)\r\n    animateArrayUpdate(animations)\r\n  }\r\n  // quickSort\r\n  function quickSort() {\r\n    setDisabled(true)\r\n    setDisableCreate(true)\r\n    setInfo(QuickSortInfo)\r\n    const animations = quickSortAnimations(intArr)\r\n    animateArrayUpdate(animations)\r\n    \r\n  }\r\n  function bubbleSort() {\r\n    setDisabled(true)\r\n    setDisableCreate(true)\r\n    setInfo(BubbleSortInfo)\r\n    const animations = bubbleSortAnimations(intArr)\r\n    animateArrayUpdate(animations)\r\n    \r\n  }\r\n\r\n\r\n  return (\r\n    <div className=\"display-container\">\r\n      <div className=\"button-container\">\r\n        <button \r\n          className=\"button\" \r\n          id=\"create-array\"\r\n          onClick={() => onClickSetIntArr()}\r\n          disabled={disableCreate}>\r\n            Create/Reset Array\r\n        </button>\r\n        <button\r\n          className=\"button\"\r\n          id=\"merge-sort\"\r\n          onClick={mergeSort}\r\n          disabled={disabled}>\r\n            MergeSort\r\n        </button>\r\n        <button\r\n          className=\"button\"\r\n          id=\"quick-sort\"\r\n          onClick={quickSort}\r\n          disabled={disabled}>\r\n            QuickSort\r\n          </button>  \r\n          <button\r\n          className=\"button\"\r\n          id=\"bubble-sort\"\r\n          onClick={bubbleSort}\r\n          disabled={disabled}>\r\n            BubbleSort\r\n          </button>  \r\n      </div>\r\n      \r\n      <div className=\"array-bar-container\" ref={containerRef}>\r\n        {intArr.map((barHeight, index) => (\r\n          <div\r\n          className=\"array-bar\"\r\n          style={{\r\n            height: `${barHeight}Vmin`,\r\n            width: `${100 / getArrayLength()}vw`,\r\n            color: 'white',\r\n          }}\r\n          key={index}\r\n          >{barHeight - getMinValue() + 1}</div>\r\n        ))}\r\n        <div \r\n        className=\"array-bar-topper\"\r\n        style={{height: `55vmin`,\r\n        width:`${100 / getArrayLength()}vw`}}></div>\r\n      </div>\r\n      <code className=\"info\">{info}</code>\r\n    </div>\r\n  )\r\n}\r\n","import React, {Component} from 'react'\r\n\r\nimport './Node.css'\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props\r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : ''\r\n\r\n    return (\r\n      <td\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></td>\r\n    )\r\n  }\r\n}","// Performs Dijkstra's algorithm returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = []\r\n  startNode.distance = 0\r\n  const unvisitedNodes = getAllNodes(grid)\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes)\r\n    const closestNode = unvisitedNodes.shift()\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder\r\n    closestNode.isVisited = true\r\n    visitedNodesInOrder.push(closestNode)\r\n    if (closestNode === finishNode) return visitedNodesInOrder\r\n    updateUnvisitedNeighbors(closestNode, grid)\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid)\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1\r\n    neighbor.previousNode = node\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = []\r\n  const {col, row} = node\r\n  if (row > 0) neighbors.push(grid[row - 1][col])\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col])\r\n  if (col > 0) neighbors.push(grid[row][col - 1])\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1])\r\n  return neighbors.filter(neighbor => !neighbor.isVisited)\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = []\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node)\r\n    }\r\n  }\r\n  return nodes\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = []\r\n  let currentNode = finishNode\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode)\r\n    currentNode = currentNode.previousNode\r\n  }\r\n  return nodesInShortestPathOrder\r\n}","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function AStar(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid); // Q: different from using grid or slice of grid???\r\n\r\n  while (unvisitedNodes.length) {\r\n    sortByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (!closestNode.isWall) {\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction sortByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}","import React, { Component } from 'react'\r\nimport Node from '../node/Node'\r\nimport { dijkstra } from '../../../algorithms/searches/Dijkstra'\r\nimport { AStar } from '../../../algorithms/searches/AStar'\r\nimport { dfs } from '../../../algorithms/searches/DepthFirstSearch'\r\nimport { bfs } from '../../../algorithms/searches/BreathFirstSearch'\r\n\r\nimport './Graph.css'\r\n\r\nexport default class Graph extends Component {\r\n  constructor() {\r\n    super()\r\n    this.state = {\r\n      grid: [],\r\n      START_NODE_ROW: 1,\r\n      FINISH_NODE_ROW: 12,\r\n      START_NODE_COL: 2,\r\n      FINISH_NODE_COL: 12,\r\n      mouseIsPressed: false,\r\n      ROW_COUNT: 15,\r\n      COLUMN_COUNT: 15,\r\n      isRunning: false,\r\n      isStartNode: false,\r\n      isFinishNode: false,\r\n      isWallNode: false, \r\n      currRow: 0,\r\n      currCol: 0,\r\n      isDesktopView: true,\r\n    }\r\n\r\n    this.handleMouseDown = this.handleMouseDown.bind(this)\r\n    this.handleMouseLeave = this.handleMouseLeave.bind(this)\r\n    this.toggleIsRunning = this.toggleIsRunning.bind(this)\r\n  }\r\n  // occurs when page loads\r\n  // create initial grid and set state\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid()\r\n    this.setState({grid})\r\n  }\r\n\r\n  toggleIsRunning() {\r\n    this.setState({isRunning: !this.state.isRunning})\r\n  }\r\n\r\n\r\n  // Create initial grid with number of rows and columns\r\n  getInitialGrid = (\r\n    rowCount = this.state.ROW_COUNT,\r\n    colCount = this.state.COLUMN_COUNT,\r\n  ) => {\r\n    const initialGrid = []\r\n    for (let row = 0; row < rowCount; row++) {\r\n      const currentRow = []\r\n      for (let col = 0; col < colCount; col++) {\r\n        currentRow.push(this.createNode(row, col))\r\n      }\r\n      initialGrid.push(currentRow)\r\n    }\r\n    return initialGrid\r\n  }\r\n\r\n  // Creates node with row and column values\r\n  createNode = (row, col) => {\r\n    return {\r\n      row,\r\n      col,\r\n      isStart:\r\n        row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n      isFinish:\r\n        row === this.state.FINISH_NODE_ROW &&\r\n        col === this.state.FINISH_NODE_COL,\r\n      distance: Infinity,\r\n      distanceToFinishNode:\r\n        Math.abs(this.state.FINISH_NODE_ROW - row) +\r\n        Math.abs(this.state.FINISH_NODE_COL - col),\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      isNode: true,\r\n    }\r\n  }\r\n\r\n // What happens when you click down on mouse\r\n  handleMouseDown(row, col) {\r\n    // check to make sure animation is not running\r\n    if (!this.state.isRunning) {\r\n      // check to see if grid is clear\r\n      if (this.isGridClear()) {\r\n        // determines if start node\r\n        if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-start'\r\n        ) {\r\n          // selects if click on start node allowing change of start\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isStartNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          })\r\n          // determines of finish node\r\n        } else if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-finish'\r\n        ) {\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isFinishNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          })\r\n        } else {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col)\r\n          this.setState({\r\n            grid: newGrid,\r\n            mouseIsPressed: true,\r\n            isWallNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          })\r\n        }\r\n      } else {\r\n        // resets grid if path search has run and click down on mouse\r\n        this.clearGrid()\r\n      }\r\n    }\r\n  }\r\n\r\n  isGridClear() {\r\n    // traverse rows of grid\r\n    for (const row of this.state.grid) {\r\n      // traverse columns of grid\r\n      for (const node of row) {\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className\r\n        if (\r\n          nodeClassName === 'node node-visited' ||\r\n          nodeClassName === 'node node-shortest-path'\r\n        ) {\r\n          return false\r\n        }\r\n      }\r\n    }\r\n    return true\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.isRunning) {\r\n      if (this.state.mouseIsPressed) {\r\n        const nodeClassName = document.getElementById(`node-${row}-${col}`)\r\n          .className\r\n        if (this.state.isStartNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevStartNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ]\r\n            prevStartNode.isStart = false\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node'\r\n\r\n            this.setState({currRow: row, currCol: col})\r\n            const currStartNode = this.state.grid[row][col]\r\n            currStartNode.isStart = true\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-start'\r\n          }\r\n          this.setState({START_NODE_ROW: row, START_NODE_COL: col})\r\n        } else if (this.state.isFinishNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevFinishNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ]\r\n            prevFinishNode.isFinish = false\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node'\r\n\r\n            this.setState({currRow: row, currCol: col})\r\n            const currFinishNode = this.state.grid[row][col]\r\n            currFinishNode.isFinish = true\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-finish'\r\n          }\r\n          this.setState({FINISH_NODE_ROW: row, FINISH_NODE_COL: col})\r\n        } else if (this.state.isWallNode) {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col)\r\n          this.setState({grid: newGrid})\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseUp(row, col) {\r\n    if (!this.state.isRunning) {\r\n      this.setState({mouseIsPressed: false})\r\n      if (this.state.isStartNode) {\r\n        const isStartNode = !this.state.isStartNode\r\n        this.setState({isStartNode, START_NODE_ROW: row, START_NODE_COL: col})\r\n      } else if (this.state.isFinishNode) {\r\n        const isFinishNode = !this.state.isFinishNode\r\n        this.setState({\r\n          isFinishNode,\r\n          FINISH_NODE_ROW: row,\r\n          FINISH_NODE_COL: col,\r\n        })\r\n      }\r\n      this.getInitialGrid()\r\n    }\r\n  }\r\n\r\n  handleMouseLeave() {\r\n    if (this.state.isStartNode) {\r\n      const isStartNode = !this.state.isStartNode\r\n      this.setState({isStartNode, mouseIsPressed: false})\r\n    } else if (this.state.isFinishNode) {\r\n      const isFinishNode = !this.state.isFinishNode\r\n      this.setState({isFinishNode, mouseIsPressed: false})\r\n    } else if (this.state.isWallNode) {\r\n      const isWallNode = !this.state.isWallNode\r\n      this.setState({isWallNode, mouseIsPressed: false})\r\n      this.getInitialGrid()\r\n    }\r\n  }\r\n\r\n  /******************** Clear Board/Walls ********************/\r\n\r\n  clearGrid() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice()\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish' &&\r\n            nodeClassName !== 'node node-wall'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node'\r\n            node.isVisited = false\r\n            node.distance = Infinity\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col)\r\n          }\r\n          if (nodeClassName === 'node node-finish') {\r\n            node.isVisited = false\r\n            node.distance = Infinity\r\n            node.distanceToFinishNode = 0\r\n          }\r\n          if (nodeClassName === 'node node-start') {\r\n            node.isVisited = false\r\n            node.distance = Infinity\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col)\r\n            node.isStart = true\r\n            node.isWall = false\r\n            node.previousNode = null\r\n            node.isNode = true\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  clearWalls() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice()\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className\r\n          if (nodeClassName === 'node node-wall') {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node'\r\n            node.isWall = false\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /******************** Create Animations ********************/\r\n  visualize(algo) {\r\n    if (!this.state.isRunning) {\r\n      this.clearGrid()\r\n      this.toggleIsRunning()\r\n      const {grid} = this.state\r\n      const startNode =\r\n        grid[this.state.START_NODE_ROW][this.state.START_NODE_COL]\r\n      const finishNode =\r\n        grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL]\r\n      let visitedNodesInOrder\r\n      switch (algo) {\r\n        case 'Dijkstra':\r\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode)\r\n          break\r\n        case 'AStar':\r\n          visitedNodesInOrder = AStar(grid, startNode, finishNode)\r\n          break\r\n        case 'BFS':\r\n          visitedNodesInOrder = bfs(grid, startNode, finishNode)\r\n          break\r\n        case 'DFS':\r\n          visitedNodesInOrder = dfs(grid, startNode, finishNode)\r\n          break\r\n        default:\r\n          // should never get here\r\n          break\r\n      }\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode)\r\n      nodesInShortestPathOrder.push('end')\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder)\r\n    }\r\n  }\r\n\r\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder)\r\n        }, 10 * i)\r\n        return\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i]\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className\r\n        if (\r\n          nodeClassName !== 'node node-start' &&\r\n          nodeClassName !== 'node node-finish'\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node node-visited'\r\n        }\r\n      }, 10 * i)\r\n    }\r\n  }\r\n\r\n  /******************** Create path from start to finish ********************/\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      if (nodesInShortestPathOrder[i] === 'end') {\r\n        setTimeout(() => {\r\n          this.toggleIsRunning()\r\n        }, i * 50)\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i]\r\n          const nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node node-shortest-path'\r\n          }\r\n        }, i * 40)\r\n      }\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const {grid, mouseIsPressed} = this.state\r\n    return (\r\n\r\n      <div className=\"main-container\">\r\n        <div className=\"instructions-container\">\r\n          <h4>Instructions</h4>\r\n        <ul className=\"instructions-list\">\r\n          <li>You  can move the start an end nodes by clicking and dragging the nodes within\r\n            the grid.\r\n          </li>\r\n          <li>You can create walls by clicking empty squares on the grid.  They will turn \r\n            black.</li>\r\n        </ul>\r\n        </div>\r\n        <div className=\"button-container-graph\">\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-danger\"\r\n            onClick={() => this.clearGrid()}>\r\n            Clear Grid\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-warning\"\r\n            onClick={() => this.clearWalls()}>\r\n            Clear Walls\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => this.visualize('Dijkstra')}>\r\n            Dijkstra's\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => this.visualize('AStar')}>\r\n            A*\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => this.visualize('BFS')}>\r\n            Bread First Search\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-primary\"\r\n            onClick={() => this.visualize('DFS')}>\r\n            Depth First Search\r\n          </button>\r\n        \r\n\r\n        <table\r\n          className=\"grid-container\"\r\n          onMouseLeave={() => this.handleMouseLeave()}>\r\n          <tbody className=\"grid\">\r\n            {grid.map((row, rowIdx) => {\r\n              return (\r\n                <tr key={rowIdx}>\r\n                  {row.map((node, nodeIdx) => {\r\n                    const {row, col, isFinish, isStart, isWall} = node\r\n                    return (\r\n                      <Node\r\n                        key={nodeIdx}\r\n                        col={col}\r\n                        isFinish={isFinish}\r\n                        isStart={isStart}\r\n                        isWall={isWall}\r\n                        mouseIsPressed={mouseIsPressed}\r\n                        onMouseDown={(row, col) =>\r\n                          this.handleMouseDown(row, col)\r\n                        }\r\n                        onMouseEnter={(row, col) =>\r\n                          this.handleMouseEnter(row, col)\r\n                        }\r\n                        onMouseUp={() => this.handleMouseUp(row, col)}\r\n                        row={row}></Node>\r\n                    )\r\n                  })}\r\n                </tr>\r\n              )\r\n            })}\r\n          </tbody>\r\n        </table> \r\n        </div>     \r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\n/******************** Create Walls ********************/\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\r\n  const newGrid = grid.slice()\r\n  const node = newGrid[row][col]\r\n  if (!node.isStart && !node.isFinish && node.isNode) {\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    }\r\n    newGrid[row][col] = newNode\r\n  }\r\n  return newGrid\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called after the path-finding methods.\r\nfunction getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = []\r\n  let currentNode = finishNode\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode)\r\n    currentNode = currentNode.previousNode\r\n  }\r\n  return nodesInShortestPathOrder\r\n}","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  let nextNodesStack = [startNode];\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.shift();\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // return visitedNodesInOrder;\r\n}","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const nextNodesStack = [];\r\n  nextNodesStack.push(startNode);\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.pop();\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","import React, {Fragment} from 'react';\r\nimport { Routes, Route } from 'react-router-dom'\r\nimport './App.css';\r\nimport Header from './components/header/Header'\r\nimport SortDisplay from './components/sort-display/SortDisplay';\r\nimport Graph from './components/path-finder/graph/Graph'\r\n\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Fragment>\r\n        <Header/>\r\n        <main>\r\n        <Routes>\r\n          <Route\r\n            path='/sort'\r\n            element={<SortDisplay/>}/>\r\n        \r\n          <Route\r\n            path='/path'\r\n            element={<Graph/>}/>\r\n          </Routes>\r\n        </main>\r\n      </Fragment>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport { BrowserRouter } from 'react-router-dom'\r\n\r\n\r\nReactDOM.render(\r\n  <BrowserRouter>\r\n    <App/>\r\n  </BrowserRouter>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}